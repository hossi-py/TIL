# 백준 [그래프 이론 / 탐색]

[TOC]

## 1. [S5 / 14397 / 해변]

```python
# 14397. 해변
dx = [-1, -1, 0, 0, 1, 1]
# x의 인덱스가 0포함 짝수일 때
dy_even = [-1, 0, -1, 1, -1, 0]
# 홀수일 때
dy_odd = [0, 1, -1, 1, 0, 1]


def dfs(x, y):
    global beach_len

    for k in range(6):
        nx = x + dx[k]

        if x % 2 == 0:
            ny = y + dy_even[k]
        else:
            ny = y + dy_odd[k]

        if 0 <= nx < N and 0 <= ny < M:
            if beach[nx][ny] == '#':
                beach_len += 1

# 세로의 크기 N / 가로의 크기 M
N, M = map(int, input().split())

beach = [list(input()) for _ in range(N)]

beach_len = 0
# 물의 위치에서 8방향으로 땅과 만나면 체크
for i in range(N):
    for j in range(M):
        if beach[i][j] == '.':
            dfs(i, j)

print(beach_len)

```



## 2. [S5 / 16173 / 점프왕 쩰리]

```python
# 16173. 점프왕 쩰리
dx = [0, 1]
dy = [1, 0]
from collections import deque


def bfs(x, y):
    q = deque()
    visited = [[0] * N for _ in range(N)]

    q.append([x, y])

    while q:
        x, y = q.popleft()
        if graph[x][y] == -1:
            return True

        jump = graph[x][y]

        for k in range(2):
            nx = x + (dx[k] * jump)
            ny = y + (dy[k] * jump)

            if 0 <= nx < N and 0 <= ny < N and visited[nx][ny] == 0:
                visited[nx][ny] = 1
                q.append([nx, ny])
    return False

N = int(input())

graph = [list(map(int, input().split())) for _ in range(N)]

# (0, 0) 시작 -> (N-1)(N-1) 종료
# 현재 칸의 수 만큼 이동할 수 있다.
# 오른쪽과 아래로만 갈 수 있다.
def solution():
    can = bfs(0, 0)
    return 'HaruHaru' if can else 'Hing'

print(solution())
```



## 3. [S3 / 3182 / 한동이는 공부가 하기 싫어!]

```python
# S3. 3182. 한동이는 공부가 하기 싫어!

N = int(input())    # 선배들 수


G = {i + 1: int(input()) for i in range(N)}     # key : 선배 번호 value : 대답

counts = [0] * (N + 1)  # 각 선배를 시작으로 몇 번 만나는지 저장
path = [0] * (N + 1)    # 방문 배열


def recursive(cur):
    if path[cur] == 1:  # cycle 발생 (이미 만났을 때)
        return 0

    path[cur] = 1   # 방문 체크

    # 실행 2 이후 cnt를 늘려 만난 선배 수를 늘린다
    cnt = recursive(G[cur]) + 1 # 다음 선배

    # 1번 선배를 먼저 만났을 때 다시 1번 선배를 만나게 된다면 시작되는 코드
    # 실행 1
    path[cur] = 0
    # 실행 2
    return cnt

for i in range(1, N + 1):
    counts[i] = recursive(i)

print(counts.index(max(counts)))
```



## 4. [S3 / 14562 / 태권왕]

```python
from collections import deque

# S3. 14562. 태권왕

# A : 현재 점수만큼 점수를 얻을 수 있는 기술 / 상대 역시 3점을 득점
# B : 1점을 얻는 기술

# S : 태균이의 현재 점수 / T : 상대의 점수
# S == T가 되는 최소 연속 발차기 횟수
def bfs(S, T):
    q = deque()
    q.append((S, T, 0))

    while q:
        t, e, cnt = q.popleft()
        # 태균이 점수가 낮을 때
        if t <= e:
            # 기술 A 썼을 때
            q.append((t * 2, e + 3, cnt + 1))
            # 기술 B 썼을 때
            q.append((t + 1, e, cnt + 1))

            # 점수 같으면
            if t == e:
                return cnt


C = int(input())

for _ in range(C):
    S, T = map(int, input().split())

    print(bfs(S, T))

```



## 5. [S3 / 16956 / 늑대와 양]

```python
# S3. 16956. 늑대와 양
R, C = map(int, input().split())

pasture = [list(input()) for _ in range(R)]

# 양(S)은 이동하지 않고 / 늑대(W)는 인접한 칸을 갈 수 있다.

# 늑대로 이동하는데 다음 칸에 양을 만나면 현재 칸에 울타리(D)를 설치한다.
dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]


flag = False
for i in range(R):
    for j in range(C):
        # 늑대라면 이동
        if pasture[i][j] == 'W':
            for k in range(4):
                nx = i + dx[k]
                ny = j + dy[k]
                
                # 늑대가 4개 방향을 모두 가는데 양을 만나면 무조건 잡아 먹힌다.
                if 0 <= nx < R and 0 <= ny < C:
                    if pasture[nx][ny] == 'S':
                        flag = True

if flag:
    print(0)

else:
    print(1)
    # 그 외에는 모두 울타리를 설치한다.
    for i in range(R):
        for j in range(C):
            if pasture[i][j] == '.':
                pasture[i][j] = 'D'

for row in pasture:
    print(''.join(row))

```

