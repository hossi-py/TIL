# 백준 [그래프 이론 / 탐색]

[TOC]

## 1. [S5 / 14397 / 해변]

```python
# 14397. 해변
dx = [-1, -1, 0, 0, 1, 1]
# x의 인덱스가 0포함 짝수일 때
dy_even = [-1, 0, -1, 1, -1, 0]
# 홀수일 때
dy_odd = [0, 1, -1, 1, 0, 1]


def dfs(x, y):
    global beach_len

    for k in range(6):
        nx = x + dx[k]

        if x % 2 == 0:
            ny = y + dy_even[k]
        else:
            ny = y + dy_odd[k]

        if 0 <= nx < N and 0 <= ny < M:
            if beach[nx][ny] == '#':
                beach_len += 1

# 세로의 크기 N / 가로의 크기 M
N, M = map(int, input().split())

beach = [list(input()) for _ in range(N)]

beach_len = 0
# 물의 위치에서 8방향으로 땅과 만나면 체크
for i in range(N):
    for j in range(M):
        if beach[i][j] == '.':
            dfs(i, j)

print(beach_len)

```



## 2. [S5 / 16173 / 점프왕 쩰리]

```python
# 16173. 점프왕 쩰리
dx = [0, 1]
dy = [1, 0]
from collections import deque


def bfs(x, y):
    q = deque()
    visited = [[0] * N for _ in range(N)]

    q.append([x, y])

    while q:
        x, y = q.popleft()
        if graph[x][y] == -1:
            return True

        jump = graph[x][y]

        for k in range(2):
            nx = x + (dx[k] * jump)
            ny = y + (dy[k] * jump)

            if 0 <= nx < N and 0 <= ny < N and visited[nx][ny] == 0:
                visited[nx][ny] = 1
                q.append([nx, ny])
    return False

N = int(input())

graph = [list(map(int, input().split())) for _ in range(N)]

# (0, 0) 시작 -> (N-1)(N-1) 종료
# 현재 칸의 수 만큼 이동할 수 있다.
# 오른쪽과 아래로만 갈 수 있다.
def solution():
    can = bfs(0, 0)
    return 'HaruHaru' if can else 'Hing'

print(solution())
```



