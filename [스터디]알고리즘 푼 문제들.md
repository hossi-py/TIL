# 알고리즘 푼 문제들

[TOC]

## 스터디원이 기존에 푼 문제들

```markdown
1001 1005 1008 1016 1019 1034 1038 1043 1049 1069 1072 1074 1083 1085 1101 1103 1107 1111 1113 1120 1149 1152 1157 1167 1194 1197 1202 1208 1214 1230 1237 1238 1244 1248 1253 1303 1305 1327 1328 1330 1339 1365 1402 1414 1422 1446 1450 1509 1516 1520 1525 1557 1629 1655 1695 1697 1708 1725 1726 1736 1743 1748 1753 1773 1781 1786 1806 1843 1865 1916 1927 1932 1937 1958 1986 1987 1992 2042 2096 2116 2146 2169 2206 2212 2252 2292 2304 2309 2407 2437 2438 2439 2440 2441 2442 2443 2468 2477 2491 2503 2527 2557 2559 2562 2563 2564 2577 2578 2583 2589 2605 2606 2628 2629 2635 2638 2662 2667 2669 2675 2718 2739 2758 2839 2884 2908 2920 3005 3015 3176 3190 3197 3665 4191 4355 4963 4991 5214 5582 6549 6603 7576 8958 9465 9498 9661 9694 9935 10026 10090 10157 10158 10163 10171 10172 10809 10814 10818 10828 10869 10950 10951 10952 10998 11404 11437 11654 11689 11720 11725 12013 12100 12837 13300 13460 13549 14502 14503 14696 14719 14725 14890 15481 15483 15552 15649 15650 15651 15652 15654 15655 15656 15657 15663 15664 15665 15666 15684 15685 15686 16235 16236 16953 17070 17135 17136 17141 17143 17215 17281 17471 17472 17825 19236 1012 1039 1149 1152 1157 1237 1260 1987 2206 2309 2468 2491 2563 2564 2578 2589 2605 2606 2638 2667 2839 4963 6603 7576 10870 11066 11660 14502 14503 14890
```



# 풀어야 하는 문제

## [1회차] 210701

```markdown
11399. ATM(S3), https://www.acmicpc.net/problem/11399(O)
11047. 동전 0(S2), https://www.acmicpc.net/problem/11047(O)
12761. 돌다리(S2), https://www.acmicpc.net/problem/12761(O)
1991. 트리 순회(S1), https://www.acmicpc.net/problem/1991(O)
1068. 트리(G5), https://www.acmicpc.net/problem/1068(O)
1261. 알고스팟(G4), https://www.acmicpc.net/problem/1261(X)
1344. 축구(G4), https://www.acmicpc.net/problem/1344(X)
1430. 공격(G4), https://www.acmicpc.net/problem/1430(X)
8980. 택배(G3), https://www.acmicpc.net/problem/8980(X)
11066. 파일 합치기(G3), https://www.acmicpc.net/problem/11066(X)
```



### 11399. ATM

```python
import sys
sys.stdin = open('2.txt', 'r')

T = 1

for tc in range(1, T+1):

    people = int(input())

    P = list(map(int, input().split()))

    min_time = 0

    P = sorted(P)

    i = 0
    sum_ = 0
    sum_list = []

    while i < len(P):
        min_time = P[i]
        sum_ += min_time
        sum_list.append(sum_)
        i += 1

    print(sum(sum_list))
```

```markdown
문제 해설 그대로 접근했음

필요한 시간의 최소합 = 오름차순 정렬

배열을 정렬해주고 반복문을 돌면서

min_time에는 해당 사람의 인출 시간

sum_list 에는 인출 시간의 합을 저장
```



### 11047. 동전 0

```python
import sys
sys.stdin = open('2.txt', 'r')

N, K = map(int, input().split())

A_list = []

for tc in range(1, N + 1):

    A_list.append(int(input()))

# 새로운 배열에 K보다 작은 값만 넣는다
new_A_list = []

for i in range(len(A_list)):
    if A_list[i] <= K:
        new_A_list.append(A_list[i])

new_A_list.reverse()

# 필요한 동전 개수
cnt = 0

# 동전 리스트 인덱스
i = 0

while K != 0:

    if K > new_A_list[i]:
        cnt += K // new_A_list[i]

        K = K % new_A_list[i]

    elif K < new_A_list[i]:
        i += 1

print(cnt)

```

```markdown
시간초과 해결을 못하겠음

풀이법 : 동전 배열에서 K보다 작거나 같은 것만 new_A_list에 담는다.

new_A_list를 내림차순 정리 후에

반복문을 통해

동전의 개수 = 목표값과 가장 큰 금액을 나누었을 때의 몫

목표값 = 목표값과 가장 큰 금액을 나누었을 때의 나머지

이때 나머지가 0이 될때까지 반복한다.
```



### 12761. 돌다리

```python
import sys
from _collections import deque
sys.stdin = open('2.txt', 'r')


def bfs(v):
    Q = deque()
    Q.append(v)
    visit[v] = 0

    # 큐가 비어있지 않은 동안
    while Q:
        v = Q.popleft()
        for w in [v-1, v+1, v-A, v+A, v-B, v+B, v*A, v*B]:
            if (0 <= w <= 100000) and visit[w] == -1:
                Q.append(w)
                visit[w] = visit[v] + 1
                if N == M:
                    return

A, B, N, M = map(int, input().split())

# 방문
visit = [-1] * 100001

bfs(N)

print(visit[M])

```

``` markdown
BFS

방문 배열 만들고

동규의 위치부터 bfs 시작

Q 생성 및 방문 처리

동규는 8개의 방법으로 이동할 수 있고

주어진 범위 내에서 이동한다

조건을 만족하면 큐에 추가되며 해당 인덱스(방문) + 1이된다.

N = M이 되면 return


```



### 1991. 트리 순회

```python
import sys
sys.stdin = open('2.txt', 'r')


def pre_order(node):
    print(node, end="")

    left = tree[node][0]
    right = tree[node][1]

    if left != '.':
        pre_order(left)
    if right != '.':
        pre_order(right)


def in_order(node):
    left = tree[node][0]
    right = tree[node][1]

    if left != '.':
        in_order(left)
    print(node, end="")
    if right != '.':
        in_order(right)


def post_order(node):

    left = tree[node][0]
    right = tree[node][1]

    if left != '.':
        post_order(left)

    if right != '.':
        post_order(right)
    print(node, end="")

N = int(input())

tree = {}

for _ in range(1, N + 1):
    node, left, right = input().split()

    tree[node] = [left, right]

pre_order('A')
print()
in_order('A')
print()
post_order('A')

```

```
전위 순회 : (루트)(왼쪽 자식)(오른쪽 자식)
중위 순회 : (왼쪽 자식)(루트)(오른쪽 자식)
후위 순회 : (왼쪽 자식)(오른쪽 자식)(루트)

1. 루트에 print(node, end="") 노드 찍기
2. 딕셔너리(tree)에 구조 만들어놓기

```



### 1068. 트리

```
1. 입력된 인덱스를 dfs함수에 트리 배열과 함께 전달한다.

2. dfs함수

  2-1. 전달받은 인덱스의 배열 값을 삭제한다는 의미로 -2로 바꾼다. (-1은 루트노드와 겹치므로 피한다.)

  2-2. 배열 전체를 탐색하며, 방금 삭제한 인덱스를 부모노드로 가지는 노드를 찾아 dfs함수를 재귀호출한다.

3. 재귀가 끝나면 삭제될 노드들은 전부 -2로 갱신되어있으므로,

   -2가 아니면서, 다른 노드의 부모노드도 아닌 원소를 찾을 때마다 count를 1씩 늘린다
```



```python
def dfs(del_node, node):
    # 삭제하는 노드는 -2로 표기
    node[del_node] = -2
    for i in range(len(node)):
        if del_node == node[i]:
            dfs(i, node)


N = int(input())

node = list(map(int, input().split()))

del_node = int(input())

cnt = 0

dfs(del_node, node)
for i in range(len(node)):
    if node[i] != -2 and i not in node:
        cnt += 1

print(cnt)
```



## [2회차] 210708

### 1138. 한 줄로 서기

```python
N = int(input())    # 사람수
line = []
people = [-1] + list(map(int, input().split()))

for i in range(N, 0, -1):   # i = 4, 3, 2, 1
    # i = 4 / people[4] = 0
    # i = 3 / people[3] = 1
    # i = 2 / people[2] = 1
    # i = 1 / people[1] = 2

    line.insert(people[i], i)
    # people[i] 번째 위치에 i를 대입한다.
    # 0번째 위치에 4 대입
    # 1번 위치에 3 대입
    # 1번 위치에 2 대입 / 기존 3은 2번 위치로 이동
    # 2번 위치에 1 대입 / 기존 3번은 3번 위치로 이동

print(*line)
```



### 1003. 피보나치 수열

```python
def fibonacci(n):
    f0 = [1, 0]
    f1 = [0, 1]

    if n == 0:
        print("1 0")
        return 0

    elif n == 1:
        print("0 1")
        return 1

    else:
        for i in range(2, n + 1):
            f0.append(f0[i-1] + f0[i-2])
            f1.append(f1[i-1] + f1[i-2])

        cnt_zero = f0.pop()
        cnt_one = f1.pop()
        print(cnt_zero, cnt_one)


T = int(input())

for tc in range(1, T + 1):

    N = int(input())

    fibonacci(N)

```

```
재귀로 하면 시간 초과.


```



### 3184. 양

```python
import sys
sys.stdin = open('2.txt', 'r')

from _collections import deque


dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

def bfs(x, y):
    global sheep, wolf
    q = deque()
    q.append((x, y))

    visit[x][y] = 1

 	#ㄱ 한 영역을 다 돌 때까지
    while q:
        x, y = q.popleft()

        # 늑대면 증가
        if field[x][y] == 'v':
            wolf += 1

        # 양이면 증가
        elif field[x][y] == 'o':
            sheep += 1

        for w in range(4):
            nx = x + dx[w]
            ny = y + dy[w]
            if 0 <= nx < R and 0 <= ny < C:
                if field[nx][ny] != '#' and visit[nx][ny] == 0:
                    visit[nx][ny] = 1
                    q.append((nx, ny))


R, C = map(int, input().split())

field = [list(input()) for _ in range(R)]

# 최종 양, 늑대 수
cnt_sheep = 0
cnt_wolf = 0

# field 방문체크
visit = [[0] * C for _ in range(R)]


for i in range(R):
    for j in range(C):
        if field[i][j] != '#' and visit[i][j] == 0:
            # 새로운 영역(bfs 돌 때)마다 양, 늑대 수 초기화
            sheep = 0
            wolf = 0
            bfs(i, j)
			
            #ㄱ while문이 한 사이클 끝나면
            # 영역 안에서 양과 늑대의 수 조건 비교
            #늑대 수 >= 양의 수 : 양 = 0
            if wolf >= sheep:
                sheep = 0
            else:
                wolf = 0

            cnt_sheep += sheep
            cnt_wolf += wolf

print(cnt_sheep, cnt_wolf)

```



### 1389. 케빈 베이컨의 6단계 법칙

```python
'''
N : 유저의 수
M : 친구 관계의 수

A, B : 친구 관계

다익스트라 알고리즘 : 하나의 정점에서 출발했을 때 다른 모든 정점으로의 최단 경로
플로이드 와샬 알고리즘: 모든 정점에서 모든 정점으로의 최단 경로
'''

N, M = map(int, input().split())

friend = [[float("inf")] * (N + 1) for _ in range(N + 1)]

# 자기 자신은 0으로 설정
for i in range(1, N + 1):
    friend[i][i] = 0

for _ in range(M):
    A, B = map(int, input().split())

    # 양방향 그래프
    friend[A][B] = 1
    friend[B][A] = 1

# 플로이드 와샬 알고리즘

# 거쳐가는 노드(k)
for k in range(1, N + 1):
    # 출발 노드(i)
    for i in range(1, N + 1):
        # 도착 노드(j)
        for j in range(1, N + 1):
            friend[i][j] = min(friend[i][j], friend[i][k] + friend[k][j])

result = [float("inf"), 0]
for i in range(1, N + 1):
    sum = 0
    for v in friend[i]:
        sum += v if v != float("inf") else 0
    if sum < result[0]:
        result = sum, i

print(result[1])
```



### 12865. 평범한 배낭

```python
N, K = map(int, input().split())

dp = [[0] * (K + 1) for _ in range(N + 1)]

for i in range(1, N + 1):   # i = 1, 2, 3, 4
    W, V = map(int, input().split())

    for j in range(1, K + 1):
        if j < W:
            dp[i][j] = dp[i-1][j]
        else:
            dp[i][j] = max(dp[i-1][j-W] + V, dp[i-1][j])

print(dp[-1][-1])

```



### 1644. 소수의 연속합

```python
import sys
sys.stdin = open('2.txt', 'r')

N = int(input())

'''
에라토스테네스의 체 = 소수 리스트 구하기
'''

# 숫자 0, 1은 False 로 두고 2부터 N까지는 True로 둔다.
isPrime = [False, False] + [True] * (N - 1)
arr = []

# 자연수 2부터 자연수 N까지
for i in range(2, N + 1):
    # 만약 True이면
    if isPrime[i]:
        # 소수 배열에 넣는다
        arr.append(i)
        # i가 소수인 경우 i의 배수들은 모두 False 판정한다.
        for j in range(2 * i, N + 1, i):
            isPrime[j] = False

'''
합쳐서 N이 되어야 함
단 소수의 연속 묶음으로 계산해야함

첫번째 인덱스부터 순차적으로 더해가면서 41보다 커지면 인덱스 +1  
'''

cnt = 0

idx = 0

sum = 0

j = 0

while idx <= len(arr)-1:
    sum += arr[idx]
    # 합이 N이면 cnt 1 증가 / sum 초기화 / idx 1 증가
    if sum == N:
        cnt += 1
        sum = 0
        idx = 0
        j += 1
        idx += j

    # 합이 N보다 크면 인덱스 1증가 / sum 초기화 반복문 재실행
    elif sum > N:
        sum = 0
        idx = 0
        j += 1
        idx += j

    # 합이 N보다 작으면 인덱스 1증가 후 반복문 재실행
    else:
        idx += 1

print(cnt)

```



## [3회차] 210715

### 1334. 다음 팰린드롬 수

```python
N = input()

# 1~8의 자연수 일 때
if len(N) == 1:
    if int(N) < 9:
        print(int(N) + 1)
    else:
        print(11)

else:
    pd = ""
    front = N[0:len(N)//2]
    back = front[::-1]
    # 입력값으로 같은 자리수의 팰린드롬 생성
    # 홀수일 때
    if len(N) % 2 != 0:
        center = N[len(N)//2]
        pd = front + center + back
        # 만약 입력값보다 생성한 값이 크다면 그대로 출력
        if int(pd) > int(N):
            print(pd)

        else:
            # 자릿수 변동이 없다면
            if int(center) < 9:
                center = str(int(center) + 1)
                pd = front + center + back
            else:
                # 중간값은 0이 되고 front +1 이 되어야 하므로
                new_front = str(int(front) + 1)
                # front 자릿수 변하지 않을 때
                if len(new_front) == len(front):
                    center = '0'
                    pd = new_front + center + new_front[::-1]
                # front 자리수가 변하게 되면
                else:
                    pd = new_front + new_front[::-1]
            print(pd)

    # 짝수일 때
    else:
        pd = front + back
        # 만약 입력값보다 생성한 값이 크다면 그대로 출력
        if int(pd) > int(N):
            print(pd)
        else:
            new_front = str(int(front) + 1)
            new_back = new_front[::-1]
            if len(new_front) > len(front):
                pd = new_front[0:len(new_front)-1] + new_back
            else:
                pd = new_front + new_back

            print(pd)
```



### 10211. Maximum Subarray

```python
import sys
sys.stdin = open('2.txt', 'r')

T = int(input())

for tc in range(1, T + 1):

    # 배열의 크기
    N = int(input())

    X = list(map(int, input().split()))

    dp = [0] * N

    dp[0] = X[0]
    for i in range(1, N):
        # 이전 + 현재 , 현재 중 비교 후 큰 것 담기
        dp[i] = max(dp[i-1] + X[i], X[i])
    print(max(dp))
```



### 2841. 외계인의 기타 연주

```python
import sys
sys.stdin = open('2.txt', 'r')

# 기타 6개 줄 / 각 줄은 P개의 프렛으로 나누어짐
# 멜로디 = 음의 연속 / 어떤 줄의 프렛을 여러개 = 가장 높은 프렛의 음 발생
# 큰 프렛을 누를 때는 손을 놔도 되지만 작은 프렛을 원하면 다른 손을 다 뗀다
# 프렛을 한 번 누르거나 뗄 때 = 손가락을 1번 움직였다
# 손가락 가장 적게

N, P = map(int, sys.stdin.readline().split())

X = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]

cnt = 0

# 줄은 총 6개
string = [[] for _ in range(7)]

for i, j in X:
    # 줄을 아무것도 누르지 않고 있으면
    if len(string[i]) == 0:
        # i번째 줄에 j번째 프렛을 누르고 누르는 횟수 + 1
        string[i].append(j)
        cnt += 1
    # 누르고 있다면
    else:
        # 만약 다음 누를 프렛이 이미 눌렀던 프렛보다 크다면
        if j > string[i][-1]:
            # i번째 줄에 j번째 프렛을 누르고 누르는 횟수 + 1
            string[i].append(j)
            cnt += 1
        # 이미 누른 프렛이라면 횟수 변화 없음
        elif j == string[i][-1]:
            continue
        # 누르고 있는 프렛보다 눌러야 하는 프렛이 작을 경우
        else:
            # i번째 줄이 비어있지 않고, 눌러야 하는 프렛(j)가 최근에 눌러진 프렛보다 작을 경우
            while len(string[i]) and j < string[i][-1]:
                # 이전에 눌렀던 프렛을 떼고 횟수 + 1
                string[i].pop()
                cnt += 1
            # 만약 i번째 줄이 비어있지 않고, 누르고 있는 프렛과 같은 경우 변화 없다
            # while문 빠져나오고 for문 반복
            if len(string[i]) and j == string[i][-1]:
                continue
            string[i].append(j)
            cnt += 1

print(cnt)

```



### 1153. 네 개의 소수

```python
import sys
sys.stdin = open('2.txt', 'r')

# 에라토스테네스의 체

N = int(sys.stdin.readline())

check = [False, False] + [True] * (N-1)

nums = []

for i in range(2, N+1):
    # 만약 해당 숫자가 True이면
    if check[i] == True:
        # 배열에 담고
        nums.append(i)
        # 해당 배수는 False로 바꾼다
        for j in range(2*i, N+1, i):
            check[j] = False

# 골드바흐의 추측
# 2를 제외한 모든 짝수는 두 소수의 합으로 나타낼 수 있다.

even = [2, 2]
odd = [2, 3]

# 입력이 8이상일 때
if N >= 8:
    # 짝수일 때
    if N % 2 == 0:
        result = N - 4
        for i in range(len(nums)):
            for j in range(len(nums)):
                if nums[i] + nums[j] == result:
                    even.append(nums[i])
                    even.append(nums[j])
                if len(even) == 4:
                    break
        print(*even)

    # 홀수일 때
    else:
        result = N - 5
        for i in range(len(nums)):
            for j in range(len(nums)):
                if nums[i] + nums[j] == result:
                    odd.append(nums[i])
                    odd.append(nums[j])
                if len(odd) == 4:
                    break
        print(*odd)

# 입력이 8 미만일 때
else:
    print(-1)

```

### 1715. 카드 정렬하기

```python
# 1715. 카드 정렬하기
import sys

sys.stdin = open('2.txt', 'r')

# 우선순위 큐 : 정렬된 상태로 저장
import heapq

N = int(sys.stdin.readline())

cardSet = []

for _ in range(N):
    heapq.heappush(cardSet, int(sys.stdin.readline()))


# 카드 묶음이 1개 일 때
if N == 1:
    print(0)
# 여러개일 때
else:
    # 비교횟수
    result = 0

    # 작은 묶음 두개를 꺼낸다
    # cardSet이 모두 묶일 때 까지 (개수 1개)
    while len(cardSet) > 1:
        A = heapq.heappop(cardSet)  # A : 제일 작은 묶음
        B = heapq.heappop(cardSet)  # B : 두번째로 작은 묶음
        result += A + B # 두 묶음을 더한다
        # 더한 값을 다시 넣는다
        heapq.heappush(cardSet, A + B)
    print(result)

```



## [4회차] 210722

### 4889. 안정적인 문자열

```python
# 4889. 안정적인 문자열
import sys

# 테스트 케이스 번호
tc = 1

while True:
    # '}' 를 '{'로 바꿔 줬을 때
    cnt = 0
    # '{'를 담을 스택
    stack = []
    # 입력값에서 개행 문자 제거
    read = sys.stdin.readline().rstrip('\n')
    # 만약 '-'가 포함되면 반복문 중단
    if read.startswith('-'):
        break

    # 입력값은 항상 짝수로 들어온다.
    # '{'가 들어왔을 때
    for text in read:
        if text == '{':
            stack.append(text)
        # '}'가 들어왔을 때
        else:
            # stack이 비어있다면 '{'로 바꾸어주고 cnt += 1
            if not stack:
                stack.append('{')
                cnt += 1
            # 비어있지 않다면 '{' 만 들어있는 스택에서 최상위 요소 제거
            else:
                stack.pop()

    # 스택에는 짝수개의 열린 괄호만 들어가게 되며 스택 길이의 절반은
    # 안정적인 문자열을 만들기 위한 최소한의 연산 수

    result = (len(stack) // 2) + cnt

    print('{}. {}'.format(tc, result))
    tc += 1

```



### 1013. Contact

```python
# 1013. contact
import sys
import re
sys.stdin = open('2.txt', 'r')

# 정규표현식
# 문자열을 받을 때, 원하는 문자열만 매치시켜준다.
'''
+ : 바로 앞의 문자가 1번 이상 등장함
() : 괄호 안의 문자를 하나로 묶음
| : OR 개념

match() : 매치가 되나 입력한 문자열의 일부인 경우도 매치시킴
fullmatch() : 문자열 전체가 매치 되는 지 확인
'''

T = int(sys.stdin.readline())
results = []

for tc in range(1, T + 1):
    signal = sys.stdin.readline().rstrip('\n')
    # 띄어쓰기가 있으면 안됨
    p = re.compile('(100+1+|01)+')
    m = p.fullmatch(signal)
    # 매치가 됐다면 YES
    if m:
        results.append('YES')
    # 매치가 안됐다면 NO
    else:
        results.append('NO')

for result in results:
    print(result)

```



### 1245. 농장관리

```python
import sys

# 1245. 농장관리

dx = [-1, 1, 0, 0, 1, 1, -1, -1]
dy = [0, 0, -1, 1, 1, -1, 1, -1]


def dfs(x, y):
    global flag
    for k in range(8):
        nx = x + dx[k]
        ny = y + dy[k]

        if 0 <= nx < N and 0 <= ny < M:
            # 기존 위치보다 새로운 위치의 높이가 높다면
            if farm[x][y] < farm[nx][ny]:
                # flag = False
                flag = False

            # 인접한 곳이 같은 높이라면 같은 산봉우리로 인식
            if visited[nx][ny] == False and farm[nx][ny] == farm[x][y]:
                visited[nx][ny] = True
                dfs(nx, ny)


N, M = map(int, sys.stdin.readline().split())

farm = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]

visited = [[False] * (M) for _ in range(N)]

flag = False    # False : 큰 높이가 있을 때 / True : 큰 높이가 없을 때

cnt = 0 # Flag = True 일 때 cnt += 1

for i in range(N):
    for j in range(M):
        if visited[i][j] == False:
            # (0, 0)을 가장 높은 위치라고 본다.
            flag = True
            dfs(i, j)

            # (0, 0)에서 dfs 돌고 봉우리 발견한 경우
            if flag:
                cnt += 1

print(cnt)
```



### 1662. 압축

```python
import sys

sys. stdin = open('2.txt', 'r')

# 1662. 압축

def rec(tmp, stack):
    while stack:
        # stack의 맨 뒤를 꺼낸다
        v = stack.pop()
        # 닫는 괄호면
        if v == ')':
            # rec 함수 재귀 tmp 변화 없음
            tmp += rec(0, stack)
        # 여는 괄호면
        elif v == '(':
            # 여는 괄호 왼쪽의 숫자를 꺼낸 후(반복 횟수)
            result = int(stack.pop())
            # tmp와 곱해준다
            tmp = tmp * result
            return tmp
        # 숫자면
        else:
            # tmp에 1 더해준다 (자릿수)
            tmp += 1
    return tmp

S = sys.stdin.readline().rstrip()

# 스택
stack = list(S)

print(rec(0, stack))


```



### 1419. 등차수열의 합

```python
import sys

# 1419. 등차수열의 합

left = int(sys.stdin.readline()) # 1 <= left < 1,000,000,000

right = int(sys.stdin.readline())    # left <= right < 1,000,000,000

k = int(sys.stdin.readline())    # 2 <= k <= 5

cnt = 0

# k = 2일 때
# x, d는 자연수 이므로 초항과 공차는 0이 될 수 없다.
# 따라서 1과 2를 제외한 모든 자연수는 두 개의 항의 합으로 나타낼 수 있다.
if k == 2:
    if right == 1:
        print(0)
    else:
        cnt = right - left + 1

        if left == 1:
            cnt = cnt - 2
        if left == 2:
            cnt = cnt - 1
        print(cnt)

# k = 4일 때
# 4x + 6d이며
# 10, 14, 16, 18, 20, .... 의 값을 가지며 4개의 항의 합으로 나타낼 수 있다.
elif k == 4:
    # left가 1 이상 10 이하일 때
    if 1 <= left <= 10:
        # right가 10 미만이면 cnt = 0
        if right < 10:
            print(0)
        # right가 10 이상이면
        else:
            # 초항이 14 공차 2인 등차수열
            num = 14
            while num < left:
                num += 2
            while num <= right:
                cnt += 1
                num += 2
            # 10을 포함해준다
            print(cnt + 1)
    # left가 11이상일 때
    else:
        num = 14
        while num < left:
            num += 2
        while num <= right:
            cnt += 1
            num += 2
        # 10을 포함하지 않는다.
        print(cnt)

# k = 3 / k = 5일 때
# 3x + 3d / 5x + 10d 이며
# num = k * (k + 1) // 2 이상의 정수 중에서
# 3의 배수(k=3)나 5의 배수(k=5)인 것들은 모두 k 개의 항의 합으로 나타낼 수 있다.
else:
    # num은 등차수열로 이루어진 k개의 항의 합 중 최솟값
    num = k * (k + 1) // 2
    while num < left:
        num += k
    while num <= right:
        cnt += 1
        num += k
    print(cnt)

```



### 2075. N번째 큰 수

```python
import sys
import heapq

# 2075. N번째 큰 수
'''
힙
1. 데이터 삽입은 왼쪽에서 오른쪽 순서로 완전 이진 트리를 구성
2. 입력된 데이터와 부모 노드의 값을 비교
3. 부모보다 작다면(최소힙) 서로의 자리를 변경
4. 2, 3의 과정을 부모보다 클 때까지 반복

부모 노드의 idx가 1일 때
- 부모 노드 idx = 자식 idx / /2
- 왼쪽 자식 노드 idx = 부모 노드 idx * 2
- 오른쪽 자식 노드 idx = 부모 노드 idx * 2 + 1
'''

N = int(sys.stdin.readline().rstrip())

chart = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]

heap = []

for i in range(N):
    for j in range(N):
        heapq.heappush(heap, chart[i][j])
        # 배열이 N개를 넘어가면
        if len(heap) > N:
            # 가장 작은 값 뺀다
            heapq.heappop(heap)

print(heap[0])

```



### 1600. 말이 되고픈 원숭이

```python
import sys

# 1600. 말이 되고픈 원숭이

# 인접한 방향
dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

# 말의 방향
hx = [-2, -2, -1, -1, 1, 1, 2, 2]
hy = [-1, 1, -2, 2, -2, 2, -1, 1]

from collections import deque

def bfs():
    global cnt
    q = deque()
    # 큐에 시작점(x=0, y=0, cnt, K)를 담는다
    q.append((0, 0, 0, K))

    while q:
        x, y, cnt, remain_k = q.popleft()
        # 말의 움직임이 가능할 때
        if remain_k >= 1:
            for k in range(8):
                nx_h = x + hx[k]
                ny_h = y + hy[k]

                # 범위조건
                if 0 <= nx_h < H and 0 <= ny_h < W and board[nx_h][ny_h] == 0:
                    # 방문하지 않았을 때
                    if visited[nx_h][ny_h] == -1 or visited[nx_h][ny_h] < remain_k - 1:
                        # 도착점 도달
                        if nx_h == H - 1 and ny_h == W - 1:
                            return cnt + 1
                        # 남은 말의 움직임 만큼 visited 배열 정리
                        visited[nx_h][ny_h] = remain_k - 1
                        # 이동 횟수 + 1 / 남아있는 말의 움직임 - 1
                        q.append((nx_h, ny_h, cnt + 1, remain_k - 1))

        # 원숭이의 움직임
        for k in range(4):
            nx = x + dx[k]
            ny = y + dy[k]

            # 범위 조건
            if 0 <= nx < H and 0 <= ny < W and board[nx][ny] == 0:
                # 방문하지 않았을 때
                if visited[nx][ny] == -1 or visited[nx][ny] < remain_k:
                    # 도착점 도달
                    if nx == H - 1 and ny == W - 1:
                        return cnt + 1
                    visited[nx][ny] = remain_k
                    q.append((nx, ny, cnt + 1, remain_k))

    return -1

# K : 말 처럼 이동할 수 있는 횟수
K = int(sys.stdin.readline())

# W : 가로 / H : 세로
W, H = map(int, sys.stdin.readline().split())

# 0 : 평지 / 1: 장애물(장애물의 위치로 이동 불가능)
board = [list(map(int, sys.stdin.readline().split())) for _ in range(H)]

visited = [[-1] * W for _ in range(H)]

cnt = 0

if W == 1 and H == 1:
    print(0)
else:
    print(bfs())

```



### 4485. 녹색 옷 입은 애가 젤다지?

```python
import sys

# 4485. 녹색 옷 입은 애가 젤다지?

dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

import heapq


def bfs():
    global tc
    heap = []
    # heap에 시작점과 시작점의 비용을 담는다
    heapq.heappush(heap, (cave[0][0], 0, 0))

    while len(heap) != 0:
        cost, x, y = heapq.heappop(heap)

        if x == N - 1 and y == N - 1:
            print('Problem {}: {}'.format(tc, visited[-1][-1]))
            break

        for k in range(4):
            nx = x + dx[k]
            ny = y + dy[k]

            # 범위체크
            if 0 <= nx < N and 0 <= ny < N:
                # 새로운 비용 계산
                total_cost = cost + cave[nx][ny]

                # 방문할 곳보다 현재 비용이 작을 때
                if total_cost < visited[nx][ny]:
                    visited[nx][ny] = total_cost
                    heapq.heappush(heap, (total_cost, nx, ny))


tc = 1

while True:
    N = int(sys.stdin.readline())

    cave = [list(map(int, sys.stdin.readline().rstrip('\n').split())) for _ in range(N)]

    if N == 0:
        break

    visited = [[float('inf')] * N for _ in range(N)]

    bfs()

    tc += 1

```



## [5회차] 210729

### 1500. 최대 곱

```python
import sys

# 1500. 최대 곱
S, K = map(int, sys.stdin.readline().split())

# 몫과 나머지 구하기

quo = S // K

rem = S % K

result = 1

# K개의 항의 합으로 = 몫(quo)를 K번 더해준다.
while K > 0:
    # 나머지가 없는 경우
    if rem == 0:
        # 몫을 K번 만큼 곱해주면 된다.
        result *= quo
    # 나머지가 있는 경우
    else:
        # K개의 항의 합을 고정 시켰기 때문에
        # 나머지를 0을 만들고 그만큼 몫에 + 1씩 해준다.
        # 몫에 + 1을 해준다
        result *= quo + 1
        # 나머지에 - 1
        rem -= 1
    K -= 1

print(result)

```



### 1188. 음식 평론가

```python
import sys

# 1188. 음식 평론가
def gcd(N, M):
    if M == 0:
        return N
    return gcd(M, N % M)


N, M = map(int, sys.stdin.readline().split())

print(M - gcd(N, M))

```



### 1599. 만식어

```python
import sys

# 1599. 민식어
N = int(sys.stdin.readline())

# key : 만식어 / value : 영어
change = {"a": "A", "b": "B", "k":"C",
            "d": "D", "e":"E", "g":"F",
            "h":"G", "i":"H", "l":"I",
            "m":"J", "n":"K",
            "o":"M", "p":"N", "r":"O",
            "s":"P", "t":"Q", "u":"R",
            "w":"S","y":"T"
            }


def toAlpha(word):
    result = word.replace('ng', 'L')
    # 알파벳으로 변환
    for k, v in change.items():
        result = result.replace(k, v)
    return result


def sol(arr):
    result = dict()
    for i in arr:
        # temp = 바뀐 문자열
        temp = toAlpha(i)
        # key : 민식어 / value : 알파벳
        result[i] = temp
    # 키값 순으로 정렬
    result = sorted(result.items(), key=lambda x : x[1])
    for i in range(len(result)):
        print(result[i][0])


arr = []

for _ in range(N):
    word = sys.stdin.readline().rstrip()
    arr.append(word)

sol(arr)

```



### 3908. 서로 다른 소수의 합

```python
import sys

# 3908. 서로 다른 소수의 합
T = int(input())

for _ in range(T):
    n, k = map(int, sys.stdin.readline().rstrip().split())

    # 소수 담는 배열
    prime = []

    check = [False, False] + [True] * (n - 1)

    for i in range(2, n + 1):
        if check[i] == True:
            prime.append(i)
            for j in range(2*i, n + 1, i):
                check[j] = False

    dp = [[0] * (k+1) for _ in range(n+1)]

    dp[0][0] = 1

    # dp[n][k] : n을 k개의 소수의 합으로 만들 수 있는 개수
    for i in range(len(prime)):
        for j in range(n, prime[i]-1, -1):
            for k in range(1, k+1):
                dp[j][k] += dp[j-prime[i]][k-1]

    print(dp[n][k])

```



### 4179. 불!

```python
import sys

# 4179. 불!
from collections import deque


def bfs():
    jihoon = deque()
    fire = deque()

    for i in range(R):
        for j in range(C):
            # 지훈이의 위치 저장
            if maze[i][j] == 'J':
                # 지훈이가 처음부터 가장자리 일 경우
                if i == 0 or i == R - 1 or j == 0 or j == C - 1:
                    return 1
                jihoon.append((i, j))
            # 불 위치 저장
            elif maze[i][j] == 'F':
                fire.append((i, j))

    cnt = 1

    while jihoon:
        # 불 확산 시작 (지훈이보다 먼저)
        for _ in range(len(fire)):
            # 불 위치
            fire_x, fire_y = fire.popleft()

            for k in range(4):
                new_fire_x = fire_x + dx[k]
                new_fire_y = fire_y + dy[k]

                # 범위 조건
                if 0 <= new_fire_x < R and 0 <= new_fire_y < C:
                    # 불의 확산 (장애물 제외)
                    if maze[new_fire_x][new_fire_y] == 'J' or maze[new_fire_x][new_fire_y] == '.':
                        maze[new_fire_x][new_fire_y] = 'F'
                        fire.append((new_fire_x, new_fire_y))

        # 불의 확산이 끝나면
        for _ in range(len(jihoon)):
            # 지훈 위치
            jihoon_x, jihoon_y = jihoon.popleft()

            for k in range(4):
                new_jihoon_x = jihoon_x + dx[k]
                new_jihoon_y = jihoon_y + dy[k]

                # 범위 조건
                if 0 <= new_jihoon_x < R and 0 <= new_jihoon_y < C:
                    # 이동 조건
                    if maze[new_jihoon_x][new_jihoon_y] == '.':
                        # 지훈이가 가장자리 도착했을 때
                        if new_jihoon_x == 0 or new_jihoon_x == R - 1 or new_jihoon_y == 0 or new_jihoon_y == C - 1:
                            return cnt + 1
                        maze[new_jihoon_x][new_jihoon_y] = 'J'
                        jihoon.append((new_jihoon_x, new_jihoon_y))
        cnt += 1
    return 'IMPOSSIBLE'


dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

R, C = map(int, sys.stdin.readline().split())

maze = [list(sys.stdin.readline().rstrip()) for _ in range(R)]

print(bfs())

```



### 2247. 실질적 약수

- 메모리 초과

```python
import sys
sys.setrecursionlimit(10**7)
# 2247. 실질적 약수

N = int(sys.stdin.readline())

# 제곱근
M = int(N ** 0.5)

result = []

ans = 0

if N <= 3:
    print(0)
else:
    while N >= 4:
        divisor = []
        divisor_back = []

        for i in range(1, M + 1):
            if N % i == 0:
                divisor.append(i)
                if (i != (N // i)):
                    divisor_back.append(N//i)

        result.append(sum(set(divisor + divisor_back))-1-N)
        N -= 1

    print(sum(result))

```



### 1563. 개근상

```python
import sys

# 1563. 개근상

# 지각 = 누적 / 결석 = 누적 X
# dp[지금까지 출결][지금까지 지각][지금까지 연속 결석]
N = int(input())

dp = [[[0 for absent in range(3)] for late in range(2)] for day in range(N)]


def check(day, late, absent):
    # 지각을 2회 이상 하거나 연속 결석 3번한 경우
    if late == 2 or absent == 3:
        return 0

    # 개근상 조건
    if day == N:
        return 1

    if dp[day][late][absent] == 0:
        # 다음날 출결
        attend = (check(day + 1, late, 0) + check(day + 1, late + 1, 0) + check(day + 1, late, absent + 1))
        # 출결 = (day+1, late, 0)
        # 지각 = (day+1, late+1, 0)
        # 결석 = (day+1, late, 1)
        dp[day][late][absent] = attend

        return attend
    else:
        return dp[day][late][absent]


print(check(0, 0, 0) % 1000000)

```



## [6회차] 210805

### 1477. 휴게소 세우기

```python
# 1477. 휴게소 세우기

# N : 현재 휴게소의 개수 / M : 새로 짓는 휴게소 개수 / L : 고속도로의 길이
N, M, L = map(int, input().split())

rest = list(map(int, input().split()))

# 휴게소 처음
rest.append(0)
# 휴게소 끝
rest.append(L-1)

rest = sorted(rest)

# 이분탐색
left = 0
right = L-1

while left <= right:
    # 휴게소 중간 지점
    mid = (left + right) // 2
    # 추가 설치한 휴게소 수
    cnt = 0
    for i in range(1, len(rest)):
        # 두 휴게소 간의 거리가 mid보다 커야 설치 가능
        if rest[i] - rest[i-1] > mid:
            # 해당 거리일 때 만들 수 있는 휴게소의 개수를 더한다.
            # 겹쳐서 세워지는 것을 방지 (1을 뺀다)
            cnt += (rest[i] - rest[i-1] - 1) // mid
    # 초과 설치 된 경우
    if cnt > M:
        # 설치 간격 넓힌다.
        left = mid + 1

    # 휴게소 설치가 덜 된 경우
    else:
        # 오른쪽 idx - 1
        right = mid - 1

print(left)

```



### 5052. 전화번호 목록

```python
import sys
# 5052. 전화번호 목록


def check(phone):
    for i in range(len(phone) - 1):
        # 정렬이 되어있으므로 i번째와 i + 1번째만 확인하면 된다.
        if phone[i] in phone[i + 1][0:len(phone[i])]:
            return False
    return True


tc = int(sys.stdin.readline())

for tc in range(1, tc + 1):
    # 전화번호 수

    n = int(sys.stdin.readline())

    phone = []

    result = []

    for _ in range(n):
        phone.append(sys.stdin.readline().rstrip('\n'))

    phone = sorted(phone)

    result.append(check(phone))

    if result[0] == False:
        print('NO')
    else:
        print('YES')

```



### 10711. 모래성

```python
# 10711. 모래성
import sys

dx = [-1, 0, 1, 0, -1, -1, 1, 1]
dy = [0, 1, 0, -1, -1, 1, 1, -1]


from collections import deque
# 한 번의 파도가 올 때마다 모래성 주위 8방향을 탐색할 필요가 없다.
# 파도가 한 번 칠 때 모래성 -1 하기 위해 모래 없는 부분을 0으로 바꿔준다.


def bfs(x, y):
    q = deque()
    for i in range(H):
        for j in range(W):
            # 모래성이 있을 때
            if castle[i][j] != '.':
                castle[i][j] = int(castle[i][j])
            # 모래성이 없을 때
            else:
                castle[i][j] = 0
                q.append((i, j))

    return q


H, W = map(int, sys.stdin.readline().rstrip().split())

castle = [list(sys.stdin.readline().rstrip()) for _ in range(H)]

wave = bfs(H, W)

cnt = [[0] * W for _ in range(H)]

# 파도가 친 횟수
result = 0

# 파도
while wave:
    x, y = wave.popleft()
    for k in range(8):
        nx = x + dx[k]
        ny = y + dy[k]

        # 범위 조건
        if 0 <= nx < H and 0 <= ny < W:
            # 파도 한 번이 올 때 주변 모래성들의 크기를 1씩 떨어뜨린다.
            if castle[nx][ny]:
                castle[nx][ny] -= 1
                # 모래성이 무너지면
                if castle[nx][ny] == 0:
                    wave.append((nx, ny))
                    # 파도가 몇 번 쳤는 지 기록
                    cnt[nx][ny] = cnt[x][y] + 1
                    result = max(result, cnt[nx][ny])

print(result)

```



### 1256. 사전

```python
import sys

# 1256. 사전
N, M, K = map(int, input().split())

# arr[a의 개수][z의 개수] = 만들 수 있는 단어 수
arr = [[1] * (M + 1) for _ in range(N + 1)]

for i in range(1, N + 1):
    for j in range(1, M + 1):
        # arr[i][j] = a 한 개 제외 + z 한 개 제외
        arr[i][j] = arr[i-1][j] + arr[i][j-1]

# 사전에 수록된 문자열의 개수가 K보다 작을 때 -1
if arr[N][M] < K:
    print(-1)

else:
    # 문자열 만들기
    result = ''
    while True:
        # 만약 a가 하나도 없거나, z가 하나도 없을 때
        if N == 0 or M == 0:
            # 단일 문자열
            result += 'a' * N
            result += 'z' * M
            break

        # 제일 앞 알파벳이 a일 때 가질 수 있는 단어의 개수는 arr[N-1][M]개
        flag = arr[N-1][M]

        # K가 flag보다 작다면
        if K <= flag:
            # 그 문자는 a를 가진다
            result += 'a'
            N -= 1
        else:
            result += 'z'
            M -= 1
            K -= flag

    print(result)

```



## [7회차] 210812

### 11053. 가장 긴 증가하는 부분 수열

```python
import sys

# 11053. 가장 긴 증가하는 부분 수열
def Lower_Bound(lis, num):
    low = 0
    high = len(lis) - 1

    while low < high:
        # 중간값 설정
        mid = int((low + high) / 2)

        # 만약 LIS의 중간값이 num보다 같거나 클 경우
        # LIS 배열에 들어갈 원본수열 값의 위치를 이분 탐색으로 찾기
        if lis[mid] >= num:
            high = mid
        else:
            low = mid + 1

    return high


N = int(input())

A = list(map(int, input().split()))

LIS = [-1]

for i in A:
    # 원본 수열의 값이 LIS의 마지막 요소보다 큰 경우
    if i > LIS[-1]:
        # LIS에 담는다
        LIS.append(i)
    else:
        # LIS 배열 중 어느 곳에 들어올 지 이분탐색
        # Lower_Bound로 값을 교환해준다.
        LIS[Lower_Bound(LIS, i)] = i


print(len(LIS[1:]))

```



### 2023. 신기한 소수

```python
import sys

# 2023. 신기한 소수

# 소수 판별
import math


def prime_check(num):
    for i in range(2, int(math.sqrt(int(num))) + 1):
        # 소수가 아님
        if int(num) % i == 0:
            return False
    
    # 소수일 때
    # N자리수가 되면 출력
    if len(num) == N:
        print(num)
        return

    # nums 숫자들을 더해준다
    for i in nums:
        prime_check(num + i)


N = int(input())

prime_num = ['2', '3', '5', '7']

nums = ['1', '3', '7', '9']

for i in prime_num:
    prime_check(i)

```



### 4781. 사탕가게

```python
# 4781. 사탕 가게

while True:
    # n : 사탕의 종류 / m : 상근이 돈
    n, m = map(float, input().split())

    n, m = int(n), int(m * 100 + 0.5)

    dp = [0 for _ in range(m + 1)]

    for i in range(1, n + 1):
        # c : 각 사탕의 칼로리 / p : 가격
        c, p = map(float, input().split())

        c, p = int(c), int(p * 100 + 0.5)

        for j in range(p, m + 1):
            # 현재 칼로리 vs 다른걸 담을 수 있다면 가격에서 뺀 후 그 가격의 칼로리 더한 값
            dp[j] = max(dp[j], dp[j-p] + c)

    if n == 0:
        break


    print(dp[-1])

```



### 1565. 수학

* 시간초과

```python
# 1565. 수학
D_Size, M_Size = map(int, input().split())

D = list(map(int, input().split()))

M = list(map(int, input().split()))


from math import gcd

# 배열 M의 사이즈가 1일 때
if M_Size == 1:
    answer = []
    cnt = 0

    # M의 사이즈가 1이면 해당 수의 약수를 모두 구한다
    for i in range(1, M[0] + 1):
        if M[0] % i == 0:
            answer.append(i)

    # 최소공배수를 구하는 배열의 사이즈가 1일 때
    if D_Size == 1:
        # 그 수가 최소공배수이다.
        lcm = D[0]

    # 최소공배수를 구하는 배열의 사이즈가 2 이상일 때
    else:
        # 최소공배수 구하기
        lcm = 0
        for i in range(1, D_Size):
            lcm = D[i - 1] * D[i] // gcd(D[i - 1], D[i])
            D[i] = lcm

    # 최대공약수의 약수들을 최소공배수로 나누었을 때 나누어 떨어지면
    # 조건을 만족한다.
    for i in range(len(answer)):
        if answer[i] % lcm == 0:
            cnt += 1

    print(cnt)

# 배열 M의 사이즈가 2 이상일 때
else:
    def find_gcd(arr):
        global ans

        cnt = 0
        answer = []

        for i in range(2, M_Size):
            ans = gcd(ans, arr[i])

        for i in range(1, ans + 1):
            if ans % i == 0:
                answer.append(i)

        if D_Size == 1:
            lcm = D[0]

        else:
            lcm = 0
            for i in range(1, D_Size):
                lcm = D[i - 1] * D[i] // gcd(D[i - 1], D[i])
                D[i] = lcm

        for i in range(len(answer)):
            if answer[i] % lcm == 0:
                cnt += 1

        print(cnt)

    ans = gcd(M[0], M[1])

    find_gcd(M)

```

```python
import sys
sys.stdin = open('2.txt', 'r')


# 1565. 수학
D_Size, M_Size = map(int, sys.stdin.readline().rstrip().split())

D = list(map(int, sys.stdin.readline().rstrip().split()))

M = list(map(int, sys.stdin.readline().rstrip().split()))


from math import gcd


# 배열의 최대공약수 구하기
for i in range(len(M)):
    # 배열의 길이가 1이면 그 값이 최대공약수
    if i == 0:
        num = M[i]
    # 길이가 2 이상이면 gcd 반복
    else:
        num = gcd(num, M[i])

# 최대 공약수의 약수 구하기
divisors = []
divisors_back = []
# 약수 구하기 = 제곱근 (시간초과 해결)
for i in range(1, int(num ** (1/2)) + 1):
    if num % i == 0:
        divisors.append(i)
        if i != (num // i):
            divisors_back.append(num//i)

result = divisors + divisors_back[::-1]

# 배열의 최소공배수 구하기
if D_Size == 1:
    n_lcm = D[0]

    cnt = 0

    for num in result:
        if num % n_lcm == 0:
            cnt += 1

    print(cnt)

else:
    def solution(arr):
        def lcm(x, y):
            return x * y // gcd(x, y)

        while True:
            # 배열의 두 값을 꺼내고
            # 두 수를 곱하고 최대공약수를 나누면 최소공배수가 나온다.
            arr.append(lcm(arr.pop(), arr.pop()))
            # 최소공배수가 나올 때 까지 반복
            if len(arr) == 1:
                return arr[0]

    n_lcm = solution(D)

    cnt = 0

    for num in result:
        if num % n_lcm == 0:
            cnt += 1

    print(cnt)

```



### 2026. 소풍

- 왜 틀렸는 지 확인

```python
import sys
sys.stdin = open('2.txt', 'r')


# 2026. 소풍
def dfs(idx, student):
    global end

    # 결과 찾으면 탐색 하지 않음
    if end:
        return

    # 멤버 수가 K가 되면
    if idx == K:
        # 종료 조건 만족
        end = True
        return

    # i = 다음에 들어 올 학생 번호
    # 만족하지 않으면 idx 는 다시 이전 단계로 간다.
    for i in range(student + 1, N + 1):

        # 먼저 들어온 학생과 다음에 들어올 학생이 친구가 아닐 때
        if result[i][student] == 0:
            continue

        # friend[j] = 소풍 멤버로 들어온 학생들
        # j = 멤버의 번호
        for j in range(0, idx):
            # 소풍 멤버에 들어온 학생들과의 친구 관계 확인
            # 아니면 종료
            if result[i][friend[j]] == 0:
                break

        # 모든 조건 만족 시 해당 학생을 소풍 멤버로 넣는다
        friend[idx] = i
        # 멤버 수 늘리고 반복
        dfs(idx + 1, i)

        if end:
            return


# K : 소풍에 갈 학생 수 / N : 학생 수 / F : 친구 관계
K, N, F = map(int, input().split())

result = [[0] * (N + 1) for _ in range(N + 1)]

for _ in range(F):
    A, B = map(int, input().split())

    # 친구 연결
    result[A][B] = 1
    result[B][A] = 1

# 학생 그룹
friend = [0] * K

# 종료 조건
end = False

# 1번 학생 부터
for i in range(1, N + 1):
    # 소풍 갈 수 있는 그룹에 넣는다.
    friend[0] = i

    # (멤버 수, 현재 학생 번호)
    dfs(1, i)

    # 종료 조건이 된다면 종료
    if end:
        break

if end:
    for answer in friend:
        print(answer)
else:
    print(-1)

```



### 1561. 놀이 공원

- 시간 초과

```python
# 1561. 놀이공원
N, M = map(int, input().split())

time = list(map(int, input().split()))

# 탑승 확인
visited = [0]

# 첫번째 아이
idx = 1

# 탑승 시간 확인
check = [0] * (M + 1)

while N > 0:
    # 놀이기구가 다 차지 않았을 때
    if len(visited) < M + 1:
        # 아이들 태우기
        visited.append(idx)
        # 시간 채우기
        check[idx] = time[idx - 1]
        N -= 1
        idx += 1

    # 다 찼을 때
    else:
        finish = min(check[1:])
        # 운행시간 대기
        for i in range(1, M + 1):
            # 가장 먼저 끝나는 놀이기구
            check[i] -= finish

        for i in range(1, len(check)):
            if check[i] == 0:
                visited[i] = idx
                check[i] = time[i - 1]
                N -= 1
                idx += 1

print(visited.index(max(visited)))
```



## [8회차] 210819

### 1043. 거짓말

```python
# 1043. 거짓말
# N : 사람 수 / M : 파티의 수
N, M = map(int, input().split())

# 진실을 아는 사람들의 번호
truth = list(map(int, input().split()))[1:]

# 스택에 추가된 적이 있는지 확인
visit = [0] * (N + 1)

for k in truth:
    visit[k] = 1

parties = []

# 파티마다 오는 사람의 번호
for _ in range(M):
    person = list(map(int, input().split()))[1:]
    parties.append(person)

# 진실을 말해야 하는 파티
party_visit = [0] * M

while truth:
    know = truth.pop()

    # 진실을 아는 사람과 같은 파티에 있는 사람들을 담는 집합
    group = set()

    # 파티마다 오는 사람들 idx만큼
    for idx in range(len(parties)):
        party = set(parties[idx])
        # 같은 파티에 있는 사람들을 찾아 집합에 추가
        if know in party:
            # 파티의 사람들을 집합에 추가
            group = group.union(party)
            party_visit[idx] = 1

    # 찾은 사람들 중 스택에 추가된 적이 없는 사람들을 스택에 추가
    for guest in group:
        if not visit[guest]:
            truth.append(guest)
            visit[guest] = 1

print(party_visit.count(0))


```



### 3190. 뱀

```python
# 3190. 뱀

# 보드의 크기
N = int(input())

# 사과의 개수
K = int(input())

# 뱀 위치
from collections import deque
snake = deque([[0, 0]])

# 북, 동, 남, 서
dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

board = [[0] * (N) for _ in range(N)]

# 사과의 위치
for _ in range(K):
    r, c = map(int, input().split())

    board[r-1][c-1] = 'a'

# 방향 전환 횟수
L = int(input())

# 변환 정보
info = {}
for _ in range(L):
    # L : 왼쪽 90도 / D : 오른쪽 90도
    sec, behavior = input().split()
    info[int(sec)] = behavior

# 첫 이동 방향
d = 1
# 시간
time = 0
# 변하는 위치
nx, ny = 0, 0


# 방향 전환 함수
def change_direction(direction):
    global d
    # 오른쪽으로 90도
    if direction == 'D':
        # 인덱스 1씩 증가
        d = (d + 1) % 4
        # 인덱스 1씩 감소
    else:
        d = (d - 1) % 4
    return d


# 범위 조건 함수
def boundary_check(x, y):
    return True if 0 <= x < N and 0 <= y < N else False


while True:
    time += 1
    # 처음에는 우측(동쪽)으로 간다
    nx += dx[d]
    ny += dy[d]

    # 방향 전환
    if time in info.keys():
        d = change_direction(info[time])

    # 범위 조건 만족
    if boundary_check(nx, ny):

        # 자기 몸에 부딪힌 경우
        if [nx, ny] in snake:
            break

        # 다음 위치에 사과가 있는 경우
        if board[nx][ny] == 'a':
            board[nx][ny] = 0
            # 길이 1 증가
            snake.append([nx, ny])

        # 사과가 없는 경우
        else:
            snake.append([nx, ny])
            x, y = snake.popleft()
    else:
        break

print(time)

```



## [9회차] 210909

### 1312. 소수

```java
import java.util.Scanner;

public class Baekjoon1312 {
	
	public static void main(String[] args) {
		double num;
		
		Scanner scanner = new Scanner(System.in);
		
		// A : 분자  B : 분모 N : N번째 자리수
		int A = scanner.nextInt();
		int B = scanner.nextInt();
		int N = scanner.nextInt();
		
		num = A / (double) B;
		
		String to = Double.toString(num);

		N = N + to.indexOf('.');

		System.out.println(to.charAt(N));
	}

}
```



### 1427. 소트인사이드

```java
import java.util.Arrays;
import java.util.Scanner;
import java.util.concurrent.ArrayBlockingQueue;

public class Baekjoon1427 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		Scanner scanner = new Scanner(System.in);
		
		// num을 문자열로 받는다.
		String num = scanner.next();
		
		// 내림차순 정렬을 위한 빈 문자열
		String answer = "";
		
		// 오름차순 정렬을 위한 char 배열
		char[] StringtoChar = num.toCharArray();
		
		Arrays.sort(StringtoChar);
		
		answer = new StringBuilder(new String(StringtoChar)).reverse().toString();
		
		System.out.println(answer);
	}
}

```



### 1476. 날짜 계산

```java
import java.util.Scanner;

public class Baekjoon1476 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		Scanner sc = new Scanner(System.in);
		
		//E : 지구를 나타내는 수
		int E = sc.nextInt();
		
		//S : 태양을 나타내는 수
		int S = sc.nextInt();
		
		//M : 달을 나타내는 수
		int M = sc.nextInt();
		
		// 시작 수
		int Estart = 0;
		int Sstart = 0;
		int Mstart = 0;
		
		// 년도
		int year = 0;
		
		while (true) {
			// 각 수 1씩 증가
			Estart ++;
			Sstart ++;
			Mstart ++;
			
			// 년도 증가
			year ++;
			
			// 각 수의 조건
			if (Estart == 16) {
				Estart = 1;
			}
			
			if (Sstart == 29) {
				Sstart = 1;
			}
			if (Mstart == 20) {
				Mstart = 1;
			}
			
			// break
			if (Estart == E && Sstart == S && Mstart == M ) {
				break;
			}
		}
		
		
		System.out.println(year);
		
	}

}

```



### 1120. 문자열

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;


public class Baekjoon1120 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		

		Scanner sc = new Scanner(System.in);
		
		String A = sc.next();
		
		String B = sc.next();
		
		// 차이
		int result = 0;
		int j = 0;
		
		// 최솟값
		int min = 9999999;
		
		// 배열 선언
		List<Integer> resultList = new ArrayList<Integer>();
		
		// 문자의 길이
		int Alen = A.length();
		int Blen = B.length();
		
		// 입력값 길이 같을 때
		if (Alen == Blen) {
			for (int i=0; i<Alen; i++) {
				if (A.charAt(i) != B.charAt(i)) {
					result ++;
				}
			}
			
			System.out.println(result);
		}
		
		// 입력값 문자열 길이 다를 때
		else {
			while (j <= (Blen-Alen)) {
				
				for (int i = 0; i < Alen; i++) {
					if (A.charAt(i) != B.charAt(i + j)) {
						result ++;
					}
				}
				resultList.add(result);
				result = 0;
				j++;
			}
			// 배열 요소 탐색
			for (int num : resultList) {
				if (num < min) {
					min = num;
				}
			}
			System.out.println(min);
		}
	}
}

```



### 17252. 삼삼한 수

```java
import java.util.Scanner;

public class Baekjoon17252 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		
		int N = sc.nextInt();
		
		Boolean check = false;
		
		if (N == 0) {
			System.out.println("NO");
		}
		
		else {
			while (N > 0) {
				// N의 나머지가 2 이상이면 거듭제곱 수 중복
				if (N % 3 > 1) {
					System.out.println("NO");
					check = true;
					break;
				}
				N = N / 3;
			}
			if (check == false) {
				System.out.println("YES");
			}
		}
	}
}

```



### 1865. 웜홀

```python
```



### 2069. 보이는 산맥

```python
# 2069. 보이는 산맥

# N개의 산봉우리
N = int(input())

arr = []

# 꼭지점의 좌표
for _ in range(N):

    x_left, x_right = map(int, input().split())

    line = []

    for j in range(1):
        line.append(x_left)
        line.append(x_right)
    arr.append(line)

# 산맥이 가림 (가려진 산맥의 밑변의 길이)
checkList = [0] * (N - 1)

for i in range(N - 1):
    if arr[i][1] > arr[i+1][0]:
        checkList[i] = abs(arr[i][1] - arr[i+1][0])

# 모든 산맥의 면적 구하기
area = 0
for moun in arr:
    # 밑변의 길이
    x = moun[1] - moun[0]
    # 높이
    h = x * 2
    # 넓이
    a = (x * h) // 2

    area += a

# 가려진 산맥의 넓이 구하기
hide_area = 0
for hide_x in checkList:
    # 높이
    hide_h = hide_x * 2
    # 넓이
    hide_a = (hide_x * hide_h) // 2

    hide_area += hide_a

print(area - hide_area)

```



### 13132. World Cup

```python
```



### 1799. 비숍

```python
```





## [10회차] 210930

### 1405. 미친로봇

```python
# 1405. 미친 로봇
d = [(-1, 0), (1, 0), (0, -1), (0, 1)]


def dfs(x, y, visited, total):
    global answer
    if len(visited) == N + 1:
        answer += total
        return

    for k in range(4):
        nx = x + d[k][0]
        ny = y + d[k][1]

        if (nx, ny) not in visited:
            visited.append((nx, ny))
            dfs(nx, ny, visited, total * probability[k])
            visited.pop()


N, e, w, s, n = map(int, input().split())

probability = [e, w, s, n]

answer = 0

dfs(0, 0, [(0, 0)], 1)

print(answer * (0.01 ** N))

```



### 2225. 합분해

`1차원 배열`

```python
# 2225. 합분해

# 한 개의 수를 여러 번 쓸 수 있다.
# 순서가 바뀐 경우는 다른 경우이다.

N, K = map(int, input().split())

# 0부터 N까지 K개 더해서 합이 N이 되는 경우 모두 구하기
answer = 0

dp = [1]

dp += [0] * N

mod = 1000000000

for _ in range(1, K + 1):
    for idx in range(1, N + 1):
        dp[idx] = (dp[idx] + dp[idx - 1]) % mod

print(dp[N])

```

`2차원 배열`

```python
import sys
sys.stdin = open('2.txt', 'r')
'''
1405 / 2225 / 1504 / 1516 / 2136
'''


# 2225. 합분해

# 한 개의 수를 여러 번 쓸 수 있다.
# 순서가 바뀐 경우는 다른 경우이다.

N, K = map(int, input().split())

# 0부터 N까지 K개 더해서 합이 N이 되는 경우 모두 구하기
answer = 0

dp = [[0] * 201 for i in range(201)]

mod = 1000000000

for i in range(201):
    dp[1][i] = 1
    dp[2][i] = i + 1

for i in range(2, 201):
    dp[i][1] = i
    for j in range(2, 201):
        dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % mod

print(dp[K][N])

```



## [11회차] 211007

### 15686. 치킨 배달

```python
from itertools import combinations

# G5. 15686. 치킨 배달

# 0 : 빈 칸 / 1 : 집 / 2 : 치킨집

N, M = map(int, input().split())

city = [list(map(int, input().split())) for _ in range(N)]

# 폐업 시키지 않을 치킨집을 최대 M개 골랐을 때, 도시의 치킨 거리의 최솟값 출력
home = []
chicken = []

for i in range(N):
    for j in range(N):
        if city[i][j] == 1:
            home.append([i, j])
        elif city[i][j] == 2:
            chicken.append([i, j])

arr = list(combinations(chicken, M))
length = 9999

for chi in arr:
    last = 0
    for h in home:
        check1 = 9999
        for c in chi:
            if check1 > abs(h[0] - c[0]) + abs(h[1] - c[1]):
                check1 = abs(h[0] - c[0]) + abs(h[1] - c[1])
        last += check1

    if length > last:
        length = last

print(length)

```

### 3933. 라그랑주의 네 제곱수 정리

```python
import math
# 3933. 라그랑주의 네 제곱수 정리

while True:
    N = int(input())
    if N == 0:
        break

    cnt = 0

    n = int(math.sqrt(N))

    for i in range(1, n + 1):
        if i ** 2 == N:
            cnt += 1

        for j in range(i, n + 1):
            if i ** 2 + j ** 2 == N:
                cnt += 1
            elif i ** 2 + j ** 2 > N:
                break

            for k in range(j, n + 1):
                if i ** 2 + j ** 2 + k ** 2 == N:
                    cnt += 1
                elif i ** 2 + j ** 2 + k ** 2 > N:
                    break

                for l in range(k, n + 1):
                    if i ** 2 + j ** 2 + k ** 2 + l ** 2 == N:
                        cnt += 1
                    elif i ** 2 + j ** 2 + k ** 2 + l ** 2 > N:
                        break

    print(cnt)

```



## [12회차] 211014

### 16172.  나는 친구가 적다 (예제는 맞지만 왜 틀린지 모름)

```python
# G3. 16172. 나는 친구가 적다 (Large)
'''
KMP 알고리즘
1. pi 배열
- pi 배열 = 찾을 문자열의 길이 만큼의 배열
- pi의 idx번째 배열에 저장하는 값 = 접두사와 접미사가 일치할 때 접두사가 j번째 까지라면 j + 1을 pi[idx]에 저장
- 예시1) aaaab = [0, 1, 2, 3, 0] abcabd = [0, 0, 0, 1, 2, 0]

pi 배열을 만들면 비교 문자열과 비교했을 때 일치하는 패턴이 0부터 k-1번째 까지 있으면 k번째부터 비교하면 된다. (k-1번째 까지는 이미 일치하는 것을 알고있음)
        0 1 2 3 4 5 6 = idx
2.  S = a a a a a b b
                0 1 2 3 4 = idx
    substring이 a a a a b 일 때

KMP
S = a a a a a b b   idx = 4에서 불일치이므로 s의 pi 배열에서 불일치한 idx - 1, pi[idx-1]의 값을 알아내고 그 값의 문자 s[pi[idx - 1]] 부터 다시 비교한다.
s = a a a a b

만약 pi[idx - 1]이 0이면 처음부터 비교해야한다.   
'''
def getPI(pattern):
    j = 0
    n = len(pattern)

    for i in range(1, n):
        while j > 0 and pattern[i] != pattern[j]:
            j = pi[j - 1]

        # pi값 찾기
        if pattern[i] == pattern[j]:
            j += 1
            pi[i] = j

    return pi


def KMP(S, pattern):
    pi = getPI(pattern)
    j = 0

    n = len(S)
    m = len(pattern)

    for i in range(n):
        while j > 0 and S[i] != pattern[j]:
            j = pi[j - 1]
        if S[i] == pattern[j]:
            if j == m - 1:
                return True
            else:
                j += 1
    return False


S = list(input())

K = list(input())

erase = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']

for s in S:
    if s in erase:
        S.remove(s)


pi = [0] * len(K)

if KMP(S, K):
    print(1)
else:
    print(0)

```



### 1727. 커플 만들기

```python
b, g = map(int, input().split())


# l : 인원이 적은 성별 / m : 인원이 많은 성별
l, m = [], []

# b(남자) g(여자) 에서 항상 g가 많다고 설정
if b > g:
    m = sorted(list(map(int, input().split())))
    l = sorted(list(map(int, input().split())))

    swap = b
    b = g
    g = swap

else:
    l = sorted(list(map(int, input().split())))
    m = sorted(list(map(int, input().split())))

dp = [[0] * 1001 for _ in range(1001)]

dp[0][0] = abs(l[0] - m[0])     # 첫번째 남자가 첫번째 여자 선택

for i in range(b):
    # 첫 번째 남자의 선택
    if i == 0:
        # 선택할 수 있는 최대 범위까지
        for j in range(1, g - (b - i - 1)):
            dp[i][j] = min(dp[i][j - 1], abs(l[0] - m[j]))  # 현재 선택한 여자와 이전의 선택한 여자 중 최솟값 저장

    # 두 번째 남자부터 선택
    else:
        for j in range(i, g - (b - i - 1)):
            if j == i:  # 두 번째 남자가 두 번째 여자 골랐을 때
                # 첫 번째 남자가 첫 번째 여자 골랐을 때를 더해준다
                dp[i][j] = dp[i - 1][j - 1] + abs(l[i] - m[j])
            else:
                # 두 번째 남자와 세 번째 여자가 만났을 때
                # 2남-3여의 절대값을 구하여서 dp[1][2]에 더하고
                # dp[2][2]와 비교하여 최솟값을 구한다.
                dp[i][j] = min(dp[i - 1][j - 1] + abs(l[i] - m[j]), dp[i][j - 1])

print(dp[b - 1][g - 1])

```

### 2551. 두 대표 자연수

```python
# 조건을 빼먹은거 같다. 왜 틀렸는 지 모르겠다.
N = int(input())

n = sorted(list(map(int, input().split())))

a = n[(N-1)//2]

b = round(sum(n)/N)
print(a, b)
```



## [13회차] 211018

### 1965. 상자넣기

```python
n = int(input())

box = list(map(int, input().split()))

# 상자의 크기가 작으면 큰 상자에 들어간다.
dp = [1] * (n + 1)  # 1개 담는걸로 초기화

for i in range(1, n):
    for j in range(i):
        # 현재 위치(i) 앞에 있는 상자와 비교
        if box[i] > box[j]:
            # i 이전 위치에서 최댓값을 찾고 찾은 값 + 1
            dp[i] = max(dp[i], dp[j] + 1)

print(max(dp))
```

### 이친수 찾기

```python
R, C = map(int, input().split())
arr = []
arduino = []
for i in range(R):
    row = list(input())
    for j in range(C):
        if row[j] == 'I':
            start = (i, j)
        elif row[j] == 'R':
            arduino.append((i, j))
    arr.append(row)

info = input()
l = len(info)
cnt = 0
move = [(), (1, -1), (1, 0), (1, 1), (0, -1), (0, 0), (0, 1), (-1, -1), (-1, 0), (-1, 1)]
for i in range(l):
    save = True
    r, c = start
    dr, dc = move[int(info[i])]
    nr, nc = r + dr, c + dc
    cnt += 1
    nxt_arduino = set()
    break_arduino = []
    for r, c in arduino:
        if r < nr:
            r += 1
        elif nr < r:
            r -= 1
        if c < nc:
            c += 1
        elif nc < c:
            c -= 1
        if (r, c) in nxt_arduino:
            break_arduino.append((r, c))
        nxt_arduino.add((r, c))

    if (nr, nc) in nxt_arduino:
        print("kraj {}".format(cnt))
        save = False
        break

    for ard in break_arduino:
        nxt_arduino.discard(ard)
    arduino = list(nxt_arduino)

    start = (nr, nc)

if save:
    final = [['.'] * C for _ in range(R)]
    final[start[0]][start[1]] = 'I'
    for r, c in arduino:
        final[r][c] = 'R'

    for i in range(R):
        print(''.join(final[i]))
```



## [14회차] 211108

### 4811. 알약

```python
# 4811. 알약

while True:
    N = int(input())

    if N == 0:
        break

    dp = [[0] * (N + 1) for _ in range(N + 1)]

    # 초기조건 : 알약을 한 개 먹는 경우
    for i in range(1, N + 1):
        dp[0][i] = 1

    # dp[i][j] : 약 반 쪽을 i번, 한 개를 j번 먹었을 때

    for i in range(1, N + 1):
        for j in range(i, N + 1):
            dp[i][j] += dp[i-1][j] + dp[i][j-1]

    print(dp[N][N])
```



### 1939. 중량제한

```python
# 1939. 중량제한
from collections import deque


def bfs(mid):
    q = deque()
    q.append(start)

    visited = set()
    visited.add(start)

    result = []

    while q:
        A = q.popleft()
        for B, C in country[A]:
            # 연결되어 있으면서 중량제한에 걸리지 않음
            if B not in visited and C >= mid:
                visited.add(B)
                q.append(B)

    # 도착지점을 방문할 수 있는 경우면 True, 아니면 False
    if end in visited:
        return True
    else:
        False


# N : 섬의 개수 / M : 다리의 개수
N, M = map(int, input().split())

country = [[] for _ in range(N + 1)]

for _ in range(M):
    # A번과 B번 섬 사이의 중량제한이 C인 다리
    A, B, C = map(int, input().split())

    # 각 도시의 연결 여부와 무게제한 저장
    country[A].append((B, C))
    country[B].append((A, C))

# 공장이 위치한 섬의 번호
start, end = map(int, input().split())

# 통과할 수 있는 중량의 최소, 최대
_min = 1
_max = 1000000000

# 이분탐색으로 최댓값 찾기
result = _min

while _min <= _max:
    mid = (_min + _max) // 2

    # 해당 무게로 start -> end까지 도착이 가능한 경우
    if bfs(mid):
        result = mid # 값 저장 후
        _min += 1 # 최댓값 구하기 위해 _min 증가
    else:
        _max = mid - 1

print(result)

```



### 8982. 수족관 1

```python
```

