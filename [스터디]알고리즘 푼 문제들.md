# 알고리즘 푼 문제들

[TOC]

## 윤호

```markdown
[그래프 탐색] 1430. 공격
[그래프 이론] 1261. 알고스팟
```



## 상훈

```markdown
1001 1005 1008 1016 1019 1034 1038 1043 1049 1069 1072 1074 1083 1085 1101 1103 1107 1111 1113 1120 1149 1152 1157 1167 1194 1197 1202 1208 1214 1230 1237 1238 1244 1248 1253 1303 1305 1327 1328 1330 1339 1365 1402 1414 1422 1446 1450 1509 1516 1520 1525 1557 1629 1655 1695 1697 1708 1725 1726 1736 1743 1748 1753 1773 1781 1786 1806 1843 1865 1916 1927 1932 1937 1958 1986 1987 1992 2042 2096 2116 2146 2169 2206 2212 2252 2292 2304 2309 2407 2437 2438 2439 2440 2441 2442 2443 2468 2477 2491 2503 2527 2557 2559 2562 2563 2564 2577 2578 2583 2589 2605 2606 2628 2629 2635 2638 2662 2667 2669 2675 2718 2739 2758 2839 2884 2908 2920 3005 3015 3176 3190 3197 3665 4191 4355 4963 4991 5214 5582 6549 6603 7576 8958 9465 9498 9661 9694 9935 10026 10090 10157 10158 10163 10171 10172 10809 10814 10818 10828 10869 10950 10951 10952 10998 11404 11437 11654 11689 11720 11725 12013 12100 12837 13300 13460 13549 14502 14503 14696 14719 14725 14890 15481 15483 15552 15649 15650 15651 15652 15654 15655 15656 15657 15663 15664 15665 15666 15684 15685 15686 16235 16236 16953 17070 17135 17136 17141 17143 17215 17281 17471 17472 17825 19236
```



## 민택

```
1012 1039 1149 1152 1157 1237 1260 1987 2206 2309 2468 2491 2563 2564 2578 2589 2605 2606 2638 2667 2839 4963 6603 7576 10870 11066 11660 14502 14503 14890
```



## 본혁

```markdown

```



## 도건

```markdown

```



# 풀어야 하는 문제

## 210701

```markdown
11399. ATM(S3), https://www.acmicpc.net/problem/11399(O)
11047. 동전 0(S2), https://www.acmicpc.net/problem/11047(O)
12761. 돌다리(S2), https://www.acmicpc.net/problem/12761(O)
1991. 트리 순회(S1), https://www.acmicpc.net/problem/1991(O)
1068. 트리(G5), https://www.acmicpc.net/problem/1068(O)
1261. 알고스팟(G4), https://www.acmicpc.net/problem/1261(X)
1344. 축구(G4), https://www.acmicpc.net/problem/1344(X)
1430. 공격(G4), https://www.acmicpc.net/problem/1430(X)
8980. 택배(G3), https://www.acmicpc.net/problem/8980(X)
11066. 파일 합치기(G3), https://www.acmicpc.net/problem/11066(X)
```



### 11399. ATM

```python
import sys
sys.stdin = open('2.txt', 'r')

T = 1

for tc in range(1, T+1):

    people = int(input())

    P = list(map(int, input().split()))

    min_time = 0

    P = sorted(P)

    i = 0
    sum_ = 0
    sum_list = []

    while i < len(P):
        min_time = P[i]
        sum_ += min_time
        sum_list.append(sum_)
        i += 1

    print(sum(sum_list))
```

```markdown
문제 해설 그대로 접근했음

필요한 시간의 최소합 = 오름차순 정렬

배열을 정렬해주고 반복문을 돌면서

min_time에는 해당 사람의 인출 시간

sum_list 에는 인출 시간의 합을 저장
```



### 11047. 동전 0

```python
import syssys.stdin = open('2.txt', 'r')N, K = map(int, input().split())A_list = []for tc in range(1, N + 1):    A_list.append(int(input()))# 새로운 배열에 K보다 작은 값만 넣는다new_A_list = []for i in range(len(A_list)):    if A_list[i] <= K:        new_A_list.append(A_list[i])new_A_list.reverse()# 필요한 동전 개수cnt = 0# 동전 리스트 인덱스i = 0while K != 0:    if K > new_A_list[i]:        cnt += K // new_A_list[i]        K = K % new_A_list[i]    elif K < new_A_list[i]:        i += 1print(cnt)
```

```markdown
시간초과 해결을 못하겠음풀이법 : 동전 배열에서 K보다 작거나 같은 것만 new_A_list에 담는다.new_A_list를 내림차순 정리 후에반복문을 통해동전의 개수 = 목표값과 가장 큰 금액을 나누었을 때의 몫목표값 = 목표값과 가장 큰 금액을 나누었을 때의 나머지이때 나머지가 0이 될때까지 반복한다.
```



### 12761. 돌다리

```python
import sysfrom _collections import dequesys.stdin = open('2.txt', 'r')def bfs(v):    Q = deque()    Q.append(v)    visit[v] = 0    # 큐가 비어있지 않은 동안    while Q:        v = Q.popleft()        for w in [v-1, v+1, v-A, v+A, v-B, v+B, v*A, v*B]:            if (0 <= w <= 100000) and visit[w] == -1:                Q.append(w)                visit[w] = visit[v] + 1                if N == M:                    returnA, B, N, M = map(int, input().split())# 방문visit = [-1] * 100001bfs(N)print(visit[M])
```

``` markdown
BFS방문 배열 만들고동규의 위치부터 bfs 시작Q 생성 및 방문 처리동규는 8개의 방법으로 이동할 수 있고주어진 범위 내에서 이동한다조건을 만족하면 큐에 추가되며 해당 인덱스(방문) + 1이된다.N = M이 되면 return
```



### 1991. 트리 순회

```python
import syssys.stdin = open('2.txt', 'r')def pre_order(node):    print(node, end="")    left = tree[node][0]    right = tree[node][1]    if left != '.':        pre_order(left)    if right != '.':        pre_order(right)def in_order(node):    left = tree[node][0]    right = tree[node][1]    if left != '.':        in_order(left)    print(node, end="")    if right != '.':        in_order(right)def post_order(node):    left = tree[node][0]    right = tree[node][1]    if left != '.':        post_order(left)    if right != '.':        post_order(right)    print(node, end="")N = int(input())tree = {}for _ in range(1, N + 1):    node, left, right = input().split()    tree[node] = [left, right]pre_order('A')print()in_order('A')print()post_order('A')
```

```
전위 순회 : (루트)(왼쪽 자식)(오른쪽 자식)중위 순회 : (왼쪽 자식)(루트)(오른쪽 자식)후위 순회 : (왼쪽 자식)(오른쪽 자식)(루트)1. 루트에 print(node, end="") 노드 찍기2. 딕셔너리(tree)에 구조 만들어놓기
```



### 1068. 트리

```
1. 입력된 인덱스를 dfs함수에 트리 배열과 함께 전달한다.2. dfs함수  2-1. 전달받은 인덱스의 배열 값을 삭제한다는 의미로 -2로 바꾼다. (-1은 루트노드와 겹치므로 피한다.)  2-2. 배열 전체를 탐색하며, 방금 삭제한 인덱스를 부모노드로 가지는 노드를 찾아 dfs함수를 재귀호출한다.3. 재귀가 끝나면 삭제될 노드들은 전부 -2로 갱신되어있으므로,   -2가 아니면서, 다른 노드의 부모노드도 아닌 원소를 찾을 때마다 count를 1씩 늘린다
```



```python
def dfs(del_node, node):    # 삭제하는 노드는 -2로 표기    node[del_node] = -2    for i in range(len(node)):        if del_node == node[i]:            dfs(i, node)N = int(input())node = list(map(int, input().split()))del_node = int(input())cnt = 0dfs(del_node, node)for i in range(len(node)):    if node[i] != -2 and i not in node:        cnt += 1print(cnt)
```

