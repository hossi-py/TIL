

[TOC]

# 회차별 푼 문제

## [1회차] 210701

```markdown
11399. ATM(S3), https://www.acmicpc.net/problem/11399(O)
11047. 동전 0(S2), https://www.acmicpc.net/problem/11047(O)
12761. 돌다리(S2), https://www.acmicpc.net/problem/12761(O)
1991. 트리 순회(S1), https://www.acmicpc.net/problem/1991(O)
1068. 트리(G5), https://www.acmicpc.net/problem/1068(O)
1261. 알고스팟(G4), https://www.acmicpc.net/problem/1261(X)
1344. 축구(G4), https://www.acmicpc.net/problem/1344(X)
1430. 공격(G4), https://www.acmicpc.net/problem/1430(X)
8980. 택배(G3), https://www.acmicpc.net/problem/8980(X)
11066. 파일 합치기(G3), https://www.acmicpc.net/problem/11066(X)
```



### 11399. ATM

```python
import sys
sys.stdin = open('2.txt', 'r')

T = 1

for tc in range(1, T+1):

    people = int(input())

    P = list(map(int, input().split()))

    min_time = 0

    P = sorted(P)

    i = 0
    sum_ = 0
    sum_list = []

    while i < len(P):
        min_time = P[i]
        sum_ += min_time
        sum_list.append(sum_)
        i += 1

    print(sum(sum_list))
```

```markdown
문제 해설 그대로 접근했음

필요한 시간의 최소합 = 오름차순 정렬

배열을 정렬해주고 반복문을 돌면서

min_time에는 해당 사람의 인출 시간

sum_list 에는 인출 시간의 합을 저장
```



### 11047. 동전 0

```python
import sys
sys.stdin = open('2.txt', 'r')

N, K = map(int, input().split())

A_list = []

for tc in range(1, N + 1):

    A_list.append(int(input()))

# 새로운 배열에 K보다 작은 값만 넣는다
new_A_list = []

for i in range(len(A_list)):
    if A_list[i] <= K:
        new_A_list.append(A_list[i])

new_A_list.reverse()

# 필요한 동전 개수
cnt = 0

# 동전 리스트 인덱스
i = 0

while K != 0:

    if K > new_A_list[i]:
        cnt += K // new_A_list[i]

        K = K % new_A_list[i]

    elif K < new_A_list[i]:
        i += 1

print(cnt)

```

```markdown
시간초과 해결을 못하겠음

풀이법 : 동전 배열에서 K보다 작거나 같은 것만 new_A_list에 담는다.

new_A_list를 내림차순 정리 후에

반복문을 통해

동전의 개수 = 목표값과 가장 큰 금액을 나누었을 때의 몫

목표값 = 목표값과 가장 큰 금액을 나누었을 때의 나머지

이때 나머지가 0이 될때까지 반복한다.
```



### 12761. 돌다리

```python
import sys
from _collections import deque
sys.stdin = open('2.txt', 'r')


def bfs(v):
    Q = deque()
    Q.append(v)
    visit[v] = 0

    # 큐가 비어있지 않은 동안
    while Q:
        v = Q.popleft()
        for w in [v-1, v+1, v-A, v+A, v-B, v+B, v*A, v*B]:
            if (0 <= w <= 100000) and visit[w] == -1:
                Q.append(w)
                visit[w] = visit[v] + 1
                if N == M:
                    return

A, B, N, M = map(int, input().split())

# 방문
visit = [-1] * 100001

bfs(N)

print(visit[M])

```

``` markdown
BFS

방문 배열 만들고

동규의 위치부터 bfs 시작

Q 생성 및 방문 처리

동규는 8개의 방법으로 이동할 수 있고

주어진 범위 내에서 이동한다

조건을 만족하면 큐에 추가되며 해당 인덱스(방문) + 1이된다.

N = M이 되면 return


```



### 1991. 트리 순회

```python
import sys
sys.stdin = open('2.txt', 'r')


def pre_order(node):
    print(node, end="")

    left = tree[node][0]
    right = tree[node][1]

    if left != '.':
        pre_order(left)
    if right != '.':
        pre_order(right)


def in_order(node):
    left = tree[node][0]
    right = tree[node][1]

    if left != '.':
        in_order(left)
    print(node, end="")
    if right != '.':
        in_order(right)


def post_order(node):

    left = tree[node][0]
    right = tree[node][1]

    if left != '.':
        post_order(left)

    if right != '.':
        post_order(right)
    print(node, end="")

N = int(input())

tree = {}

for _ in range(1, N + 1):
    node, left, right = input().split()

    tree[node] = [left, right]

pre_order('A')
print()
in_order('A')
print()
post_order('A')

```

```
전위 순회 : (루트)(왼쪽 자식)(오른쪽 자식)
중위 순회 : (왼쪽 자식)(루트)(오른쪽 자식)
후위 순회 : (왼쪽 자식)(오른쪽 자식)(루트)

1. 루트에 print(node, end="") 노드 찍기
2. 딕셔너리(tree)에 구조 만들어놓기

```



### 1068. 트리

```
1. 입력된 인덱스를 dfs함수에 트리 배열과 함께 전달한다.

2. dfs함수

  2-1. 전달받은 인덱스의 배열 값을 삭제한다는 의미로 -2로 바꾼다. (-1은 루트노드와 겹치므로 피한다.)

  2-2. 배열 전체를 탐색하며, 방금 삭제한 인덱스를 부모노드로 가지는 노드를 찾아 dfs함수를 재귀호출한다.

3. 재귀가 끝나면 삭제될 노드들은 전부 -2로 갱신되어있으므로,

   -2가 아니면서, 다른 노드의 부모노드도 아닌 원소를 찾을 때마다 count를 1씩 늘린다
```



```python
def dfs(del_node, node):
    # 삭제하는 노드는 -2로 표기
    node[del_node] = -2
    for i in range(len(node)):
        if del_node == node[i]:
            dfs(i, node)


N = int(input())

node = list(map(int, input().split()))

del_node = int(input())

cnt = 0

dfs(del_node, node)
for i in range(len(node)):
    if node[i] != -2 and i not in node:
        cnt += 1

print(cnt)
```



## [2회차] 210708

### 1138. 한 줄로 서기

```python
N = int(input())    # 사람수
line = []
people = [-1] + list(map(int, input().split()))

for i in range(N, 0, -1):   # i = 4, 3, 2, 1
    # i = 4 / people[4] = 0
    # i = 3 / people[3] = 1
    # i = 2 / people[2] = 1
    # i = 1 / people[1] = 2

    line.insert(people[i], i)
    # people[i] 번째 위치에 i를 대입한다.
    # 0번째 위치에 4 대입
    # 1번 위치에 3 대입
    # 1번 위치에 2 대입 / 기존 3은 2번 위치로 이동
    # 2번 위치에 1 대입 / 기존 3번은 3번 위치로 이동

print(*line)
```



### 1003. 피보나치 수열

```python
def fibonacci(n):
    f0 = [1, 0]
    f1 = [0, 1]

    if n == 0:
        print("1 0")
        return 0

    elif n == 1:
        print("0 1")
        return 1

    else:
        for i in range(2, n + 1):
            f0.append(f0[i-1] + f0[i-2])
            f1.append(f1[i-1] + f1[i-2])

        cnt_zero = f0.pop()
        cnt_one = f1.pop()
        print(cnt_zero, cnt_one)


T = int(input())

for tc in range(1, T + 1):

    N = int(input())

    fibonacci(N)

```

```
재귀로 하면 시간 초과.


```



### 3184. 양

```python
import sys
sys.stdin = open('2.txt', 'r')

from _collections import deque


dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

def bfs(x, y):
    global sheep, wolf
    q = deque()
    q.append((x, y))

    visit[x][y] = 1

 	#ㄱ 한 영역을 다 돌 때까지
    while q:
        x, y = q.popleft()

        # 늑대면 증가
        if field[x][y] == 'v':
            wolf += 1

        # 양이면 증가
        elif field[x][y] == 'o':
            sheep += 1

        for w in range(4):
            nx = x + dx[w]
            ny = y + dy[w]
            if 0 <= nx < R and 0 <= ny < C:
                if field[nx][ny] != '#' and visit[nx][ny] == 0:
                    visit[nx][ny] = 1
                    q.append((nx, ny))


R, C = map(int, input().split())

field = [list(input()) for _ in range(R)]

# 최종 양, 늑대 수
cnt_sheep = 0
cnt_wolf = 0

# field 방문체크
visit = [[0] * C for _ in range(R)]


for i in range(R):
    for j in range(C):
        if field[i][j] != '#' and visit[i][j] == 0:
            # 새로운 영역(bfs 돌 때)마다 양, 늑대 수 초기화
            sheep = 0
            wolf = 0
            bfs(i, j)
			
            #ㄱ while문이 한 사이클 끝나면
            # 영역 안에서 양과 늑대의 수 조건 비교
            #늑대 수 >= 양의 수 : 양 = 0
            if wolf >= sheep:
                sheep = 0
            else:
                wolf = 0

            cnt_sheep += sheep
            cnt_wolf += wolf

print(cnt_sheep, cnt_wolf)

```



### 1389. 케빈 베이컨의 6단계 법칙

```python
'''
N : 유저의 수
M : 친구 관계의 수

A, B : 친구 관계

다익스트라 알고리즘 : 하나의 정점에서 출발했을 때 다른 모든 정점으로의 최단 경로
플로이드 와샬 알고리즘: 모든 정점에서 모든 정점으로의 최단 경로
'''

N, M = map(int, input().split())

friend = [[float("inf")] * (N + 1) for _ in range(N + 1)]

# 자기 자신은 0으로 설정
for i in range(1, N + 1):
    friend[i][i] = 0

for _ in range(M):
    A, B = map(int, input().split())

    # 양방향 그래프
    friend[A][B] = 1
    friend[B][A] = 1

# 플로이드 와샬 알고리즘

# 거쳐가는 노드(k)
for k in range(1, N + 1):
    # 출발 노드(i)
    for i in range(1, N + 1):
        # 도착 노드(j)
        for j in range(1, N + 1):
            friend[i][j] = min(friend[i][j], friend[i][k] + friend[k][j])

result = [float("inf"), 0]
for i in range(1, N + 1):
    sum = 0
    for v in friend[i]:
        sum += v if v != float("inf") else 0
    if sum < result[0]:
        result = sum, i

print(result[1])
```



### 12865. 평범한 배낭

```python
N, K = map(int, input().split())

dp = [[0] * (K + 1) for _ in range(N + 1)]

for i in range(1, N + 1):   # i = 1, 2, 3, 4
    W, V = map(int, input().split())

    for j in range(1, K + 1):
        if j < W:
            dp[i][j] = dp[i-1][j]
        else:
            dp[i][j] = max(dp[i-1][j-W] + V, dp[i-1][j])

print(dp[-1][-1])

```



### 1644. 소수의 연속합

```python
import sys
sys.stdin = open('2.txt', 'r')

N = int(input())

'''
에라토스테네스의 체 = 소수 리스트 구하기
'''

# 숫자 0, 1은 False 로 두고 2부터 N까지는 True로 둔다.
isPrime = [False, False] + [True] * (N - 1)
arr = []

# 자연수 2부터 자연수 N까지
for i in range(2, N + 1):
    # 만약 True이면
    if isPrime[i]:
        # 소수 배열에 넣는다
        arr.append(i)
        # i가 소수인 경우 i의 배수들은 모두 False 판정한다.
        for j in range(2 * i, N + 1, i):
            isPrime[j] = False

'''
합쳐서 N이 되어야 함
단 소수의 연속 묶음으로 계산해야함

첫번째 인덱스부터 순차적으로 더해가면서 41보다 커지면 인덱스 +1  
'''

cnt = 0

idx = 0

sum = 0

j = 0

while idx <= len(arr)-1:
    sum += arr[idx]
    # 합이 N이면 cnt 1 증가 / sum 초기화 / idx 1 증가
    if sum == N:
        cnt += 1
        sum = 0
        idx = 0
        j += 1
        idx += j

    # 합이 N보다 크면 인덱스 1증가 / sum 초기화 반복문 재실행
    elif sum > N:
        sum = 0
        idx = 0
        j += 1
        idx += j

    # 합이 N보다 작으면 인덱스 1증가 후 반복문 재실행
    else:
        idx += 1

print(cnt)

```



## [3회차] 210715

### 1334. 다음 팰린드롬 수

```python
N = input()

# 1~8의 자연수 일 때
if len(N) == 1:
    if int(N) < 9:
        print(int(N) + 1)
    else:
        print(11)

else:
    pd = ""
    front = N[0:len(N)//2]
    back = front[::-1]
    # 입력값으로 같은 자리수의 팰린드롬 생성
    # 홀수일 때
    if len(N) % 2 != 0:
        center = N[len(N)//2]
        pd = front + center + back
        # 만약 입력값보다 생성한 값이 크다면 그대로 출력
        if int(pd) > int(N):
            print(pd)

        else:
            # 자릿수 변동이 없다면
            if int(center) < 9:
                center = str(int(center) + 1)
                pd = front + center + back
            else:
                # 중간값은 0이 되고 front +1 이 되어야 하므로
                new_front = str(int(front) + 1)
                # front 자릿수 변하지 않을 때
                if len(new_front) == len(front):
                    center = '0'
                    pd = new_front + center + new_front[::-1]
                # front 자리수가 변하게 되면
                else:
                    pd = new_front + new_front[::-1]
            print(pd)

    # 짝수일 때
    else:
        pd = front + back
        # 만약 입력값보다 생성한 값이 크다면 그대로 출력
        if int(pd) > int(N):
            print(pd)
        else:
            new_front = str(int(front) + 1)
            new_back = new_front[::-1]
            if len(new_front) > len(front):
                pd = new_front[0:len(new_front)-1] + new_back
            else:
                pd = new_front + new_back

            print(pd)
```



### 10211. Maximum Subarray

```python
import sys
sys.stdin = open('2.txt', 'r')

T = int(input())

for tc in range(1, T + 1):

    # 배열의 크기
    N = int(input())

    X = list(map(int, input().split()))

    dp = [0] * N

    dp[0] = X[0]
    for i in range(1, N):
        # 이전 + 현재 , 현재 중 비교 후 큰 것 담기
        dp[i] = max(dp[i-1] + X[i], X[i])
    print(max(dp))
```



### 2841. 외계인의 기타 연주

```python
import sys
sys.stdin = open('2.txt', 'r')

# 기타 6개 줄 / 각 줄은 P개의 프렛으로 나누어짐
# 멜로디 = 음의 연속 / 어떤 줄의 프렛을 여러개 = 가장 높은 프렛의 음 발생
# 큰 프렛을 누를 때는 손을 놔도 되지만 작은 프렛을 원하면 다른 손을 다 뗀다
# 프렛을 한 번 누르거나 뗄 때 = 손가락을 1번 움직였다
# 손가락 가장 적게

N, P = map(int, sys.stdin.readline().split())

X = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]

cnt = 0

# 줄은 총 6개
string = [[] for _ in range(7)]

for i, j in X:
    # 줄을 아무것도 누르지 않고 있으면
    if len(string[i]) == 0:
        # i번째 줄에 j번째 프렛을 누르고 누르는 횟수 + 1
        string[i].append(j)
        cnt += 1
    # 누르고 있다면
    else:
        # 만약 다음 누를 프렛이 이미 눌렀던 프렛보다 크다면
        if j > string[i][-1]:
            # i번째 줄에 j번째 프렛을 누르고 누르는 횟수 + 1
            string[i].append(j)
            cnt += 1
        # 이미 누른 프렛이라면 횟수 변화 없음
        elif j == string[i][-1]:
            continue
        # 누르고 있는 프렛보다 눌러야 하는 프렛이 작을 경우
        else:
            # i번째 줄이 비어있지 않고, 눌러야 하는 프렛(j)가 최근에 눌러진 프렛보다 작을 경우
            while len(string[i]) and j < string[i][-1]:
                # 이전에 눌렀던 프렛을 떼고 횟수 + 1
                string[i].pop()
                cnt += 1
            # 만약 i번째 줄이 비어있지 않고, 누르고 있는 프렛과 같은 경우 변화 없다
            # while문 빠져나오고 for문 반복
            if len(string[i]) and j == string[i][-1]:
                continue
            string[i].append(j)
            cnt += 1

print(cnt)

```



### 1153. 네 개의 소수

```python
import sys
sys.stdin = open('2.txt', 'r')

# 에라토스테네스의 체

N = int(sys.stdin.readline())

check = [False, False] + [True] * (N-1)

nums = []

for i in range(2, N+1):
    # 만약 해당 숫자가 True이면
    if check[i] == True:
        # 배열에 담고
        nums.append(i)
        # 해당 배수는 False로 바꾼다
        for j in range(2*i, N+1, i):
            check[j] = False

# 골드바흐의 추측
# 2를 제외한 모든 짝수는 두 소수의 합으로 나타낼 수 있다.

even = [2, 2]
odd = [2, 3]

# 입력이 8이상일 때
if N >= 8:
    # 짝수일 때
    if N % 2 == 0:
        result = N - 4
        for i in range(len(nums)):
            for j in range(len(nums)):
                if nums[i] + nums[j] == result:
                    even.append(nums[i])
                    even.append(nums[j])
                if len(even) == 4:
                    break
        print(*even)

    # 홀수일 때
    else:
        result = N - 5
        for i in range(len(nums)):
            for j in range(len(nums)):
                if nums[i] + nums[j] == result:
                    odd.append(nums[i])
                    odd.append(nums[j])
                if len(odd) == 4:
                    break
        print(*odd)

# 입력이 8 미만일 때
else:
    print(-1)

```

### 1715. 카드 정렬하기

```python
# 1715. 카드 정렬하기
import sys

sys.stdin = open('2.txt', 'r')

# 우선순위 큐 : 정렬된 상태로 저장
import heapq

N = int(sys.stdin.readline())

cardSet = []

for _ in range(N):
    heapq.heappush(cardSet, int(sys.stdin.readline()))


# 카드 묶음이 1개 일 때
if N == 1:
    print(0)
# 여러개일 때
else:
    # 비교횟수
    result = 0

    # 작은 묶음 두개를 꺼낸다
    # cardSet이 모두 묶일 때 까지 (개수 1개)
    while len(cardSet) > 1:
        A = heapq.heappop(cardSet)  # A : 제일 작은 묶음
        B = heapq.heappop(cardSet)  # B : 두번째로 작은 묶음
        result += A + B # 두 묶음을 더한다
        # 더한 값을 다시 넣는다
        heapq.heappush(cardSet, A + B)
    print(result)

```



## [4회차] 210722

### 4889. 안정적인 문자열

```python
# 4889. 안정적인 문자열
import sys

# 테스트 케이스 번호
tc = 1

while True:
    # '}' 를 '{'로 바꿔 줬을 때
    cnt = 0
    # '{'를 담을 스택
    stack = []
    # 입력값에서 개행 문자 제거
    read = sys.stdin.readline().rstrip('\n')
    # 만약 '-'가 포함되면 반복문 중단
    if read.startswith('-'):
        break

    # 입력값은 항상 짝수로 들어온다.
    # '{'가 들어왔을 때
    for text in read:
        if text == '{':
            stack.append(text)
        # '}'가 들어왔을 때
        else:
            # stack이 비어있다면 '{'로 바꾸어주고 cnt += 1
            if not stack:
                stack.append('{')
                cnt += 1
            # 비어있지 않다면 '{' 만 들어있는 스택에서 최상위 요소 제거
            else:
                stack.pop()

    # 스택에는 짝수개의 열린 괄호만 들어가게 되며 스택 길이의 절반은
    # 안정적인 문자열을 만들기 위한 최소한의 연산 수

    result = (len(stack) // 2) + cnt

    print('{}. {}'.format(tc, result))
    tc += 1

```



### 1013. Contact

```python
# 1013. contact
import sys
import re
sys.stdin = open('2.txt', 'r')

# 정규표현식
# 문자열을 받을 때, 원하는 문자열만 매치시켜준다.
'''
+ : 바로 앞의 문자가 1번 이상 등장함
() : 괄호 안의 문자를 하나로 묶음
| : OR 개념

match() : 매치가 되나 입력한 문자열의 일부인 경우도 매치시킴
fullmatch() : 문자열 전체가 매치 되는 지 확인
'''

T = int(sys.stdin.readline())
results = []

for tc in range(1, T + 1):
    signal = sys.stdin.readline().rstrip('\n')
    # 띄어쓰기가 있으면 안됨
    p = re.compile('(100+1+|01)+')
    m = p.fullmatch(signal)
    # 매치가 됐다면 YES
    if m:
        results.append('YES')
    # 매치가 안됐다면 NO
    else:
        results.append('NO')

for result in results:
    print(result)

```



### 1245. 농장관리

```python
import sys

# 1245. 농장관리

dx = [-1, 1, 0, 0, 1, 1, -1, -1]
dy = [0, 0, -1, 1, 1, -1, 1, -1]


def dfs(x, y):
    global flag
    for k in range(8):
        nx = x + dx[k]
        ny = y + dy[k]

        if 0 <= nx < N and 0 <= ny < M:
            # 기존 위치보다 새로운 위치의 높이가 높다면
            if farm[x][y] < farm[nx][ny]:
                # flag = False
                flag = False

            # 인접한 곳이 같은 높이라면 같은 산봉우리로 인식
            if visited[nx][ny] == False and farm[nx][ny] == farm[x][y]:
                visited[nx][ny] = True
                dfs(nx, ny)


N, M = map(int, sys.stdin.readline().split())

farm = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]

visited = [[False] * (M) for _ in range(N)]

flag = False    # False : 큰 높이가 있을 때 / True : 큰 높이가 없을 때

cnt = 0 # Flag = True 일 때 cnt += 1

for i in range(N):
    for j in range(M):
        if visited[i][j] == False:
            # (0, 0)을 가장 높은 위치라고 본다.
            flag = True
            dfs(i, j)

            # (0, 0)에서 dfs 돌고 봉우리 발견한 경우
            if flag:
                cnt += 1

print(cnt)
```



### 1662. 압축

```python
import sys

sys. stdin = open('2.txt', 'r')

# 1662. 압축

def rec(tmp, stack):
    while stack:
        # stack의 맨 뒤를 꺼낸다
        v = stack.pop()
        # 닫는 괄호면
        if v == ')':
            # rec 함수 재귀 tmp 변화 없음
            tmp += rec(0, stack)
        # 여는 괄호면
        elif v == '(':
            # 여는 괄호 왼쪽의 숫자를 꺼낸 후(반복 횟수)
            result = int(stack.pop())
            # tmp와 곱해준다
            tmp = tmp * result
            return tmp
        # 숫자면
        else:
            # tmp에 1 더해준다 (자릿수)
            tmp += 1
    return tmp

S = sys.stdin.readline().rstrip()

# 스택
stack = list(S)

print(rec(0, stack))


```



### 1419. 등차수열의 합

```python
import sys

# 1419. 등차수열의 합

left = int(sys.stdin.readline()) # 1 <= left < 1,000,000,000

right = int(sys.stdin.readline())    # left <= right < 1,000,000,000

k = int(sys.stdin.readline())    # 2 <= k <= 5

cnt = 0

# k = 2일 때
# x, d는 자연수 이므로 초항과 공차는 0이 될 수 없다.
# 따라서 1과 2를 제외한 모든 자연수는 두 개의 항의 합으로 나타낼 수 있다.
if k == 2:
    if right == 1:
        print(0)
    else:
        cnt = right - left + 1

        if left == 1:
            cnt = cnt - 2
        if left == 2:
            cnt = cnt - 1
        print(cnt)

# k = 4일 때
# 4x + 6d이며
# 10, 14, 16, 18, 20, .... 의 값을 가지며 4개의 항의 합으로 나타낼 수 있다.
elif k == 4:
    # left가 1 이상 10 이하일 때
    if 1 <= left <= 10:
        # right가 10 미만이면 cnt = 0
        if right < 10:
            print(0)
        # right가 10 이상이면
        else:
            # 초항이 14 공차 2인 등차수열
            num = 14
            while num < left:
                num += 2
            while num <= right:
                cnt += 1
                num += 2
            # 10을 포함해준다
            print(cnt + 1)
    # left가 11이상일 때
    else:
        num = 14
        while num < left:
            num += 2
        while num <= right:
            cnt += 1
            num += 2
        # 10을 포함하지 않는다.
        print(cnt)

# k = 3 / k = 5일 때
# 3x + 3d / 5x + 10d 이며
# num = k * (k + 1) // 2 이상의 정수 중에서
# 3의 배수(k=3)나 5의 배수(k=5)인 것들은 모두 k 개의 항의 합으로 나타낼 수 있다.
else:
    # num은 등차수열로 이루어진 k개의 항의 합 중 최솟값
    num = k * (k + 1) // 2
    while num < left:
        num += k
    while num <= right:
        cnt += 1
        num += k
    print(cnt)

```



### 2075. N번째 큰 수

```python
import sys
import heapq

# 2075. N번째 큰 수
'''
힙
1. 데이터 삽입은 왼쪽에서 오른쪽 순서로 완전 이진 트리를 구성
2. 입력된 데이터와 부모 노드의 값을 비교
3. 부모보다 작다면(최소힙) 서로의 자리를 변경
4. 2, 3의 과정을 부모보다 클 때까지 반복

부모 노드의 idx가 1일 때
- 부모 노드 idx = 자식 idx / /2
- 왼쪽 자식 노드 idx = 부모 노드 idx * 2
- 오른쪽 자식 노드 idx = 부모 노드 idx * 2 + 1
'''

N = int(sys.stdin.readline().rstrip())

chart = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]

heap = []

for i in range(N):
    for j in range(N):
        heapq.heappush(heap, chart[i][j])
        # 배열이 N개를 넘어가면
        if len(heap) > N:
            # 가장 작은 값 뺀다
            heapq.heappop(heap)

print(heap[0])

```



### 1600. 말이 되고픈 원숭이

```python
import sys

# 1600. 말이 되고픈 원숭이

# 인접한 방향
dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

# 말의 방향
hx = [-2, -2, -1, -1, 1, 1, 2, 2]
hy = [-1, 1, -2, 2, -2, 2, -1, 1]

from collections import deque

def bfs():
    global cnt
    q = deque()
    # 큐에 시작점(x=0, y=0, cnt, K)를 담는다
    q.append((0, 0, 0, K))

    while q:
        x, y, cnt, remain_k = q.popleft()
        # 말의 움직임이 가능할 때
        if remain_k >= 1:
            for k in range(8):
                nx_h = x + hx[k]
                ny_h = y + hy[k]

                # 범위조건
                if 0 <= nx_h < H and 0 <= ny_h < W and board[nx_h][ny_h] == 0:
                    # 방문하지 않았을 때
                    if visited[nx_h][ny_h] == -1 or visited[nx_h][ny_h] < remain_k - 1:
                        # 도착점 도달
                        if nx_h == H - 1 and ny_h == W - 1:
                            return cnt + 1
                        # 남은 말의 움직임 만큼 visited 배열 정리
                        visited[nx_h][ny_h] = remain_k - 1
                        # 이동 횟수 + 1 / 남아있는 말의 움직임 - 1
                        q.append((nx_h, ny_h, cnt + 1, remain_k - 1))

        # 원숭이의 움직임
        for k in range(4):
            nx = x + dx[k]
            ny = y + dy[k]

            # 범위 조건
            if 0 <= nx < H and 0 <= ny < W and board[nx][ny] == 0:
                # 방문하지 않았을 때
                if visited[nx][ny] == -1 or visited[nx][ny] < remain_k:
                    # 도착점 도달
                    if nx == H - 1 and ny == W - 1:
                        return cnt + 1
                    visited[nx][ny] = remain_k
                    q.append((nx, ny, cnt + 1, remain_k))

    return -1

# K : 말 처럼 이동할 수 있는 횟수
K = int(sys.stdin.readline())

# W : 가로 / H : 세로
W, H = map(int, sys.stdin.readline().split())

# 0 : 평지 / 1: 장애물(장애물의 위치로 이동 불가능)
board = [list(map(int, sys.stdin.readline().split())) for _ in range(H)]

visited = [[-1] * W for _ in range(H)]

cnt = 0

if W == 1 and H == 1:
    print(0)
else:
    print(bfs())

```



### 4485. 녹색 옷 입은 애가 젤다지?

```python
import sys

# 4485. 녹색 옷 입은 애가 젤다지?

dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

import heapq


def bfs():
    global tc
    heap = []
    # heap에 시작점과 시작점의 비용을 담는다
    heapq.heappush(heap, (cave[0][0], 0, 0))

    while len(heap) != 0:
        cost, x, y = heapq.heappop(heap)

        if x == N - 1 and y == N - 1:
            print('Problem {}: {}'.format(tc, visited[-1][-1]))
            break

        for k in range(4):
            nx = x + dx[k]
            ny = y + dy[k]

            # 범위체크
            if 0 <= nx < N and 0 <= ny < N:
                # 새로운 비용 계산
                total_cost = cost + cave[nx][ny]

                # 방문할 곳보다 현재 비용이 작을 때
                if total_cost < visited[nx][ny]:
                    visited[nx][ny] = total_cost
                    heapq.heappush(heap, (total_cost, nx, ny))


tc = 1

while True:
    N = int(sys.stdin.readline())

    cave = [list(map(int, sys.stdin.readline().rstrip('\n').split())) for _ in range(N)]

    if N == 0:
        break

    visited = [[float('inf')] * N for _ in range(N)]

    bfs()

    tc += 1

```



## [5회차] 210729

### 1500. 최대 곱

```python
import sys

# 1500. 최대 곱
S, K = map(int, sys.stdin.readline().split())

# 몫과 나머지 구하기

quo = S // K

rem = S % K

result = 1

# K개의 항의 합으로 = 몫(quo)를 K번 더해준다.
while K > 0:
    # 나머지가 없는 경우
    if rem == 0:
        # 몫을 K번 만큼 곱해주면 된다.
        result *= quo
    # 나머지가 있는 경우
    else:
        # K개의 항의 합을 고정 시켰기 때문에
        # 나머지를 0을 만들고 그만큼 몫에 + 1씩 해준다.
        # 몫에 + 1을 해준다
        result *= quo + 1
        # 나머지에 - 1
        rem -= 1
    K -= 1

print(result)

```



### 1188. 음식 평론가

```python
import sys

# 1188. 음식 평론가
def gcd(N, M):
    if M == 0:
        return N
    return gcd(M, N % M)


N, M = map(int, sys.stdin.readline().split())

print(M - gcd(N, M))

```



### 1599. 만식어

```python
import sys

# 1599. 민식어
N = int(sys.stdin.readline())

# key : 만식어 / value : 영어
change = {"a": "A", "b": "B", "k":"C",
            "d": "D", "e":"E", "g":"F",
            "h":"G", "i":"H", "l":"I",
            "m":"J", "n":"K",
            "o":"M", "p":"N", "r":"O",
            "s":"P", "t":"Q", "u":"R",
            "w":"S","y":"T"
            }


def toAlpha(word):
    result = word.replace('ng', 'L')
    # 알파벳으로 변환
    for k, v in change.items():
        result = result.replace(k, v)
    return result


def sol(arr):
    result = dict()
    for i in arr:
        # temp = 바뀐 문자열
        temp = toAlpha(i)
        # key : 민식어 / value : 알파벳
        result[i] = temp
    # 키값 순으로 정렬
    result = sorted(result.items(), key=lambda x : x[1])
    for i in range(len(result)):
        print(result[i][0])


arr = []

for _ in range(N):
    word = sys.stdin.readline().rstrip()
    arr.append(word)

sol(arr)

```



### 3908. 서로 다른 소수의 합

```python
import sys

# 3908. 서로 다른 소수의 합
T = int(input())

for _ in range(T):
    n, k = map(int, sys.stdin.readline().rstrip().split())

    # 소수 담는 배열
    prime = []

    check = [False, False] + [True] * (n - 1)

    for i in range(2, n + 1):
        if check[i] == True:
            prime.append(i)
            for j in range(2*i, n + 1, i):
                check[j] = False

    dp = [[0] * (k+1) for _ in range(n+1)]

    dp[0][0] = 1

    # dp[n][k] : n을 k개의 소수의 합으로 만들 수 있는 개수
    for i in range(len(prime)):
        for j in range(n, prime[i]-1, -1):
            for k in range(1, k+1):
                dp[j][k] += dp[j-prime[i]][k-1]

    print(dp[n][k])

```



### 4179. 불!

```python
import sys

# 4179. 불!
from collections import deque


def bfs():
    jihoon = deque()
    fire = deque()

    for i in range(R):
        for j in range(C):
            # 지훈이의 위치 저장
            if maze[i][j] == 'J':
                # 지훈이가 처음부터 가장자리 일 경우
                if i == 0 or i == R - 1 or j == 0 or j == C - 1:
                    return 1
                jihoon.append((i, j))
            # 불 위치 저장
            elif maze[i][j] == 'F':
                fire.append((i, j))

    cnt = 1

    while jihoon:
        # 불 확산 시작 (지훈이보다 먼저)
        for _ in range(len(fire)):
            # 불 위치
            fire_x, fire_y = fire.popleft()

            for k in range(4):
                new_fire_x = fire_x + dx[k]
                new_fire_y = fire_y + dy[k]

                # 범위 조건
                if 0 <= new_fire_x < R and 0 <= new_fire_y < C:
                    # 불의 확산 (장애물 제외)
                    if maze[new_fire_x][new_fire_y] == 'J' or maze[new_fire_x][new_fire_y] == '.':
                        maze[new_fire_x][new_fire_y] = 'F'
                        fire.append((new_fire_x, new_fire_y))

        # 불의 확산이 끝나면
        for _ in range(len(jihoon)):
            # 지훈 위치
            jihoon_x, jihoon_y = jihoon.popleft()

            for k in range(4):
                new_jihoon_x = jihoon_x + dx[k]
                new_jihoon_y = jihoon_y + dy[k]

                # 범위 조건
                if 0 <= new_jihoon_x < R and 0 <= new_jihoon_y < C:
                    # 이동 조건
                    if maze[new_jihoon_x][new_jihoon_y] == '.':
                        # 지훈이가 가장자리 도착했을 때
                        if new_jihoon_x == 0 or new_jihoon_x == R - 1 or new_jihoon_y == 0 or new_jihoon_y == C - 1:
                            return cnt + 1
                        maze[new_jihoon_x][new_jihoon_y] = 'J'
                        jihoon.append((new_jihoon_x, new_jihoon_y))
        cnt += 1
    return 'IMPOSSIBLE'


dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

R, C = map(int, sys.stdin.readline().split())

maze = [list(sys.stdin.readline().rstrip()) for _ in range(R)]

print(bfs())

```



### 2247. 실질적 약수

- 메모리 초과

```python
import sys
sys.setrecursionlimit(10**7)
# 2247. 실질적 약수

N = int(sys.stdin.readline())

# 제곱근
M = int(N ** 0.5)

result = []

ans = 0

if N <= 3:
    print(0)
else:
    while N >= 4:
        divisor = []
        divisor_back = []

        for i in range(1, M + 1):
            if N % i == 0:
                divisor.append(i)
                if (i != (N // i)):
                    divisor_back.append(N//i)

        result.append(sum(set(divisor + divisor_back))-1-N)
        N -= 1

    print(sum(result))

```



### 1563. 개근상

```python
import sys

# 1563. 개근상

# 지각 = 누적 / 결석 = 누적 X
# dp[지금까지 출결][지금까지 지각][지금까지 연속 결석]
N = int(input())

dp = [[[0 for absent in range(3)] for late in range(2)] for day in range(N)]


def check(day, late, absent):
    # 지각을 2회 이상 하거나 연속 결석 3번한 경우
    if late == 2 or absent == 3:
        return 0

    # 개근상 조건
    if day == N:
        return 1

    if dp[day][late][absent] == 0:
        # 다음날 출결
        attend = (check(day + 1, late, 0) + check(day + 1, late + 1, 0) + check(day + 1, late, absent + 1))
        # 출결 = (day+1, late, 0)
        # 지각 = (day+1, late+1, 0)
        # 결석 = (day+1, late, 1)
        dp[day][late][absent] = attend

        return attend
    else:
        return dp[day][late][absent]


print(check(0, 0, 0) % 1000000)

```



## [6회차] 210805

### 1477. 휴게소 세우기

```python
# 1477. 휴게소 세우기

# N : 현재 휴게소의 개수 / M : 새로 짓는 휴게소 개수 / L : 고속도로의 길이
N, M, L = map(int, input().split())

rest = list(map(int, input().split()))

# 휴게소 처음
rest.append(0)
# 휴게소 끝
rest.append(L-1)

rest = sorted(rest)

# 이분탐색
left = 0
right = L-1

while left <= right:
    # 휴게소 중간 지점
    mid = (left + right) // 2
    # 추가 설치한 휴게소 수
    cnt = 0
    for i in range(1, len(rest)):
        # 두 휴게소 간의 거리가 mid보다 커야 설치 가능
        if rest[i] - rest[i-1] > mid:
            # 해당 거리일 때 만들 수 있는 휴게소의 개수를 더한다.
            # 겹쳐서 세워지는 것을 방지 (1을 뺀다)
            cnt += (rest[i] - rest[i-1] - 1) // mid
    # 초과 설치 된 경우
    if cnt > M:
        # 설치 간격 넓힌다.
        left = mid + 1

    # 휴게소 설치가 덜 된 경우
    else:
        # 오른쪽 idx - 1
        right = mid - 1

print(left)

```



### 5052. 전화번호 목록

```python
import sys
# 5052. 전화번호 목록


def check(phone):
    for i in range(len(phone) - 1):
        # 정렬이 되어있으므로 i번째와 i + 1번째만 확인하면 된다.
        if phone[i] in phone[i + 1][0:len(phone[i])]:
            return False
    return True


tc = int(sys.stdin.readline())

for tc in range(1, tc + 1):
    # 전화번호 수

    n = int(sys.stdin.readline())

    phone = []

    result = []

    for _ in range(n):
        phone.append(sys.stdin.readline().rstrip('\n'))

    phone = sorted(phone)

    result.append(check(phone))

    if result[0] == False:
        print('NO')
    else:
        print('YES')

```



### 10711. 모래성

```python
# 10711. 모래성
import sys

dx = [-1, 0, 1, 0, -1, -1, 1, 1]
dy = [0, 1, 0, -1, -1, 1, 1, -1]


from collections import deque
# 한 번의 파도가 올 때마다 모래성 주위 8방향을 탐색할 필요가 없다.
# 파도가 한 번 칠 때 모래성 -1 하기 위해 모래 없는 부분을 0으로 바꿔준다.


def bfs(x, y):
    q = deque()
    for i in range(H):
        for j in range(W):
            # 모래성이 있을 때
            if castle[i][j] != '.':
                castle[i][j] = int(castle[i][j])
            # 모래성이 없을 때
            else:
                castle[i][j] = 0
                q.append((i, j))

    return q


H, W = map(int, sys.stdin.readline().rstrip().split())

castle = [list(sys.stdin.readline().rstrip()) for _ in range(H)]

wave = bfs(H, W)

cnt = [[0] * W for _ in range(H)]

# 파도가 친 횟수
result = 0

# 파도
while wave:
    x, y = wave.popleft()
    for k in range(8):
        nx = x + dx[k]
        ny = y + dy[k]

        # 범위 조건
        if 0 <= nx < H and 0 <= ny < W:
            # 파도 한 번이 올 때 주변 모래성들의 크기를 1씩 떨어뜨린다.
            if castle[nx][ny]:
                castle[nx][ny] -= 1
                # 모래성이 무너지면
                if castle[nx][ny] == 0:
                    wave.append((nx, ny))
                    # 파도가 몇 번 쳤는 지 기록
                    cnt[nx][ny] = cnt[x][y] + 1
                    result = max(result, cnt[nx][ny])

print(result)

```



### 1256. 사전

```python
import sys

# 1256. 사전
N, M, K = map(int, input().split())

# arr[a의 개수][z의 개수] = 만들 수 있는 단어 수
arr = [[1] * (M + 1) for _ in range(N + 1)]

for i in range(1, N + 1):
    for j in range(1, M + 1):
        # arr[i][j] = a 한 개 제외 + z 한 개 제외
        arr[i][j] = arr[i-1][j] + arr[i][j-1]

# 사전에 수록된 문자열의 개수가 K보다 작을 때 -1
if arr[N][M] < K:
    print(-1)

else:
    # 문자열 만들기
    result = ''
    while True:
        # 만약 a가 하나도 없거나, z가 하나도 없을 때
        if N == 0 or M == 0:
            # 단일 문자열
            result += 'a' * N
            result += 'z' * M
            break

        # 제일 앞 알파벳이 a일 때 가질 수 있는 단어의 개수는 arr[N-1][M]개
        flag = arr[N-1][M]

        # K가 flag보다 작다면
        if K <= flag:
            # 그 문자는 a를 가진다
            result += 'a'
            N -= 1
        else:
            result += 'z'
            M -= 1
            K -= flag

    print(result)

```



## [7회차] 210812

### 11053. 가장 긴 증가하는 부분 수열

```python
import sys

# 11053. 가장 긴 증가하는 부분 수열
def Lower_Bound(lis, num):
    low = 0
    high = len(lis) - 1

    while low < high:
        # 중간값 설정
        mid = int((low + high) / 2)

        # 만약 LIS의 중간값이 num보다 같거나 클 경우
        # LIS 배열에 들어갈 원본수열 값의 위치를 이분 탐색으로 찾기
        if lis[mid] >= num:
            high = mid
        else:
            low = mid + 1

    return high


N = int(input())

A = list(map(int, input().split()))

LIS = [-1]

for i in A:
    # 원본 수열의 값이 LIS의 마지막 요소보다 큰 경우
    if i > LIS[-1]:
        # LIS에 담는다
        LIS.append(i)
    else:
        # LIS 배열 중 어느 곳에 들어올 지 이분탐색
        # Lower_Bound로 값을 교환해준다.
        LIS[Lower_Bound(LIS, i)] = i


print(len(LIS[1:]))

```



### 2023. 신기한 소수

```python
import sys

# 2023. 신기한 소수

# 소수 판별
import math


def prime_check(num):
    for i in range(2, int(math.sqrt(int(num))) + 1):
        # 소수가 아님
        if int(num) % i == 0:
            return False
    
    # 소수일 때
    # N자리수가 되면 출력
    if len(num) == N:
        print(num)
        return

    # nums 숫자들을 더해준다
    for i in nums:
        prime_check(num + i)


N = int(input())

prime_num = ['2', '3', '5', '7']

nums = ['1', '3', '7', '9']

for i in prime_num:
    prime_check(i)

```



### 4781. 사탕가게

```python
# 4781. 사탕 가게

while True:
    # n : 사탕의 종류 / m : 상근이 돈
    n, m = map(float, input().split())

    n, m = int(n), int(m * 100 + 0.5)

    dp = [0 for _ in range(m + 1)]

    for i in range(1, n + 1):
        # c : 각 사탕의 칼로리 / p : 가격
        c, p = map(float, input().split())

        c, p = int(c), int(p * 100 + 0.5)

        for j in range(p, m + 1):
            # 현재 칼로리 vs 다른걸 담을 수 있다면 가격에서 뺀 후 그 가격의 칼로리 더한 값
            dp[j] = max(dp[j], dp[j-p] + c)

    if n == 0:
        break


    print(dp[-1])

```



### 1565. 수학

* 시간초과

```python
# 1565. 수학
D_Size, M_Size = map(int, input().split())

D = list(map(int, input().split()))

M = list(map(int, input().split()))


from math import gcd

# 배열 M의 사이즈가 1일 때
if M_Size == 1:
    answer = []
    cnt = 0

    # M의 사이즈가 1이면 해당 수의 약수를 모두 구한다
    for i in range(1, M[0] + 1):
        if M[0] % i == 0:
            answer.append(i)

    # 최소공배수를 구하는 배열의 사이즈가 1일 때
    if D_Size == 1:
        # 그 수가 최소공배수이다.
        lcm = D[0]

    # 최소공배수를 구하는 배열의 사이즈가 2 이상일 때
    else:
        # 최소공배수 구하기
        lcm = 0
        for i in range(1, D_Size):
            lcm = D[i - 1] * D[i] // gcd(D[i - 1], D[i])
            D[i] = lcm

    # 최대공약수의 약수들을 최소공배수로 나누었을 때 나누어 떨어지면
    # 조건을 만족한다.
    for i in range(len(answer)):
        if answer[i] % lcm == 0:
            cnt += 1

    print(cnt)

# 배열 M의 사이즈가 2 이상일 때
else:
    def find_gcd(arr):
        global ans

        cnt = 0
        answer = []

        for i in range(2, M_Size):
            ans = gcd(ans, arr[i])

        for i in range(1, ans + 1):
            if ans % i == 0:
                answer.append(i)

        if D_Size == 1:
            lcm = D[0]

        else:
            lcm = 0
            for i in range(1, D_Size):
                lcm = D[i - 1] * D[i] // gcd(D[i - 1], D[i])
                D[i] = lcm

        for i in range(len(answer)):
            if answer[i] % lcm == 0:
                cnt += 1

        print(cnt)

    ans = gcd(M[0], M[1])

    find_gcd(M)

```

```python
import sys
sys.stdin = open('2.txt', 'r')


# 1565. 수학
D_Size, M_Size = map(int, sys.stdin.readline().rstrip().split())

D = list(map(int, sys.stdin.readline().rstrip().split()))

M = list(map(int, sys.stdin.readline().rstrip().split()))


from math import gcd


# 배열의 최대공약수 구하기
for i in range(len(M)):
    # 배열의 길이가 1이면 그 값이 최대공약수
    if i == 0:
        num = M[i]
    # 길이가 2 이상이면 gcd 반복
    else:
        num = gcd(num, M[i])

# 최대 공약수의 약수 구하기
divisors = []
divisors_back = []
# 약수 구하기 = 제곱근 (시간초과 해결)
for i in range(1, int(num ** (1/2)) + 1):
    if num % i == 0:
        divisors.append(i)
        if i != (num // i):
            divisors_back.append(num//i)

result = divisors + divisors_back[::-1]

# 배열의 최소공배수 구하기
if D_Size == 1:
    n_lcm = D[0]

    cnt = 0

    for num in result:
        if num % n_lcm == 0:
            cnt += 1

    print(cnt)

else:
    def solution(arr):
        def lcm(x, y):
            return x * y // gcd(x, y)

        while True:
            # 배열의 두 값을 꺼내고
            # 두 수를 곱하고 최대공약수를 나누면 최소공배수가 나온다.
            arr.append(lcm(arr.pop(), arr.pop()))
            # 최소공배수가 나올 때 까지 반복
            if len(arr) == 1:
                return arr[0]

    n_lcm = solution(D)

    cnt = 0

    for num in result:
        if num % n_lcm == 0:
            cnt += 1

    print(cnt)

```



### 2026. 소풍

- 왜 틀렸는 지 확인

```python
import sys
sys.stdin = open('2.txt', 'r')


# 2026. 소풍
def dfs(idx, student):
    global end

    # 결과 찾으면 탐색 하지 않음
    if end:
        return

    # 멤버 수가 K가 되면
    if idx == K:
        # 종료 조건 만족
        end = True
        return

    # i = 다음에 들어 올 학생 번호
    # 만족하지 않으면 idx 는 다시 이전 단계로 간다.
    for i in range(student + 1, N + 1):

        # 먼저 들어온 학생과 다음에 들어올 학생이 친구가 아닐 때
        if result[i][student] == 0:
            continue

        # friend[j] = 소풍 멤버로 들어온 학생들
        # j = 멤버의 번호
        for j in range(0, idx):
            # 소풍 멤버에 들어온 학생들과의 친구 관계 확인
            # 아니면 종료
            if result[i][friend[j]] == 0:
                break

        # 모든 조건 만족 시 해당 학생을 소풍 멤버로 넣는다
        friend[idx] = i
        # 멤버 수 늘리고 반복
        dfs(idx + 1, i)

        if end:
            return


# K : 소풍에 갈 학생 수 / N : 학생 수 / F : 친구 관계
K, N, F = map(int, input().split())

result = [[0] * (N + 1) for _ in range(N + 1)]

for _ in range(F):
    A, B = map(int, input().split())

    # 친구 연결
    result[A][B] = 1
    result[B][A] = 1

# 학생 그룹
friend = [0] * K

# 종료 조건
end = False

# 1번 학생 부터
for i in range(1, N + 1):
    # 소풍 갈 수 있는 그룹에 넣는다.
    friend[0] = i

    # (멤버 수, 현재 학생 번호)
    dfs(1, i)

    # 종료 조건이 된다면 종료
    if end:
        break

if end:
    for answer in friend:
        print(answer)
else:
    print(-1)

```



### 1561. 놀이 공원

- 시간 초과

```python
# 1561. 놀이공원
N, M = map(int, input().split())

time = list(map(int, input().split()))

# 탑승 확인
visited = [0]

# 첫번째 아이
idx = 1

# 탑승 시간 확인
check = [0] * (M + 1)

while N > 0:
    # 놀이기구가 다 차지 않았을 때
    if len(visited) < M + 1:
        # 아이들 태우기
        visited.append(idx)
        # 시간 채우기
        check[idx] = time[idx - 1]
        N -= 1
        idx += 1

    # 다 찼을 때
    else:
        finish = min(check[1:])
        # 운행시간 대기
        for i in range(1, M + 1):
            # 가장 먼저 끝나는 놀이기구
            check[i] -= finish

        for i in range(1, len(check)):
            if check[i] == 0:
                visited[i] = idx
                check[i] = time[i - 1]
                N -= 1
                idx += 1

print(visited.index(max(visited)))
```



## [8회차] 210819

### 1043. 거짓말

```python
# 1043. 거짓말
# N : 사람 수 / M : 파티의 수
N, M = map(int, input().split())

# 진실을 아는 사람들의 번호
truth = list(map(int, input().split()))[1:]

# 스택에 추가된 적이 있는지 확인
visit = [0] * (N + 1)

for k in truth:
    visit[k] = 1

parties = []

# 파티마다 오는 사람의 번호
for _ in range(M):
    person = list(map(int, input().split()))[1:]
    parties.append(person)

# 진실을 말해야 하는 파티
party_visit = [0] * M

while truth:
    know = truth.pop()

    # 진실을 아는 사람과 같은 파티에 있는 사람들을 담는 집합
    group = set()

    # 파티마다 오는 사람들 idx만큼
    for idx in range(len(parties)):
        party = set(parties[idx])
        # 같은 파티에 있는 사람들을 찾아 집합에 추가
        if know in party:
            # 파티의 사람들을 집합에 추가
            group = group.union(party)
            party_visit[idx] = 1

    # 찾은 사람들 중 스택에 추가된 적이 없는 사람들을 스택에 추가
    for guest in group:
        if not visit[guest]:
            truth.append(guest)
            visit[guest] = 1

print(party_visit.count(0))


```



### 3190. 뱀

```python
# 3190. 뱀

# 보드의 크기
N = int(input())

# 사과의 개수
K = int(input())

# 뱀 위치
from collections import deque
snake = deque([[0, 0]])

# 북, 동, 남, 서
dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

board = [[0] * (N) for _ in range(N)]

# 사과의 위치
for _ in range(K):
    r, c = map(int, input().split())

    board[r-1][c-1] = 'a'

# 방향 전환 횟수
L = int(input())

# 변환 정보
info = {}
for _ in range(L):
    # L : 왼쪽 90도 / D : 오른쪽 90도
    sec, behavior = input().split()
    info[int(sec)] = behavior

# 첫 이동 방향
d = 1
# 시간
time = 0
# 변하는 위치
nx, ny = 0, 0


# 방향 전환 함수
def change_direction(direction):
    global d
    # 오른쪽으로 90도
    if direction == 'D':
        # 인덱스 1씩 증가
        d = (d + 1) % 4
        # 인덱스 1씩 감소
    else:
        d = (d - 1) % 4
    return d


# 범위 조건 함수
def boundary_check(x, y):
    return True if 0 <= x < N and 0 <= y < N else False


while True:
    time += 1
    # 처음에는 우측(동쪽)으로 간다
    nx += dx[d]
    ny += dy[d]

    # 방향 전환
    if time in info.keys():
        d = change_direction(info[time])

    # 범위 조건 만족
    if boundary_check(nx, ny):

        # 자기 몸에 부딪힌 경우
        if [nx, ny] in snake:
            break

        # 다음 위치에 사과가 있는 경우
        if board[nx][ny] == 'a':
            board[nx][ny] = 0
            # 길이 1 증가
            snake.append([nx, ny])

        # 사과가 없는 경우
        else:
            snake.append([nx, ny])
            x, y = snake.popleft()
    else:
        break

print(time)

```



## [9회차] 210909

### 1312. 소수

```java
import java.util.Scanner;

public class Baekjoon1312 {
	
	public static void main(String[] args) {
		double num;
		
		Scanner scanner = new Scanner(System.in);
		
		// A : 분자  B : 분모 N : N번째 자리수
		int A = scanner.nextInt();
		int B = scanner.nextInt();
		int N = scanner.nextInt();
		
		num = A / (double) B;
		
		String to = Double.toString(num);

		N = N + to.indexOf('.');

		System.out.println(to.charAt(N));
	}

}
```



### 1427. 소트인사이드

```java
import java.util.Arrays;
import java.util.Scanner;
import java.util.concurrent.ArrayBlockingQueue;

public class Baekjoon1427 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		Scanner scanner = new Scanner(System.in);
		
		// num을 문자열로 받는다.
		String num = scanner.next();
		
		// 내림차순 정렬을 위한 빈 문자열
		String answer = "";
		
		// 오름차순 정렬을 위한 char 배열
		char[] StringtoChar = num.toCharArray();
		
		Arrays.sort(StringtoChar);
		
		answer = new StringBuilder(new String(StringtoChar)).reverse().toString();
		
		System.out.println(answer);
	}
}

```



### 1476. 날짜 계산

```java
import java.util.Scanner;

public class Baekjoon1476 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		Scanner sc = new Scanner(System.in);
		
		//E : 지구를 나타내는 수
		int E = sc.nextInt();
		
		//S : 태양을 나타내는 수
		int S = sc.nextInt();
		
		//M : 달을 나타내는 수
		int M = sc.nextInt();
		
		// 시작 수
		int Estart = 0;
		int Sstart = 0;
		int Mstart = 0;
		
		// 년도
		int year = 0;
		
		while (true) {
			// 각 수 1씩 증가
			Estart ++;
			Sstart ++;
			Mstart ++;
			
			// 년도 증가
			year ++;
			
			// 각 수의 조건
			if (Estart == 16) {
				Estart = 1;
			}
			
			if (Sstart == 29) {
				Sstart = 1;
			}
			if (Mstart == 20) {
				Mstart = 1;
			}
			
			// break
			if (Estart == E && Sstart == S && Mstart == M ) {
				break;
			}
		}
		
		
		System.out.println(year);
		
	}

}

```



### 1120. 문자열

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;


public class Baekjoon1120 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		

		Scanner sc = new Scanner(System.in);
		
		String A = sc.next();
		
		String B = sc.next();
		
		// 차이
		int result = 0;
		int j = 0;
		
		// 최솟값
		int min = 9999999;
		
		// 배열 선언
		List<Integer> resultList = new ArrayList<Integer>();
		
		// 문자의 길이
		int Alen = A.length();
		int Blen = B.length();
		
		// 입력값 길이 같을 때
		if (Alen == Blen) {
			for (int i=0; i<Alen; i++) {
				if (A.charAt(i) != B.charAt(i)) {
					result ++;
				}
			}
			
			System.out.println(result);
		}
		
		// 입력값 문자열 길이 다를 때
		else {
			while (j <= (Blen-Alen)) {
				
				for (int i = 0; i < Alen; i++) {
					if (A.charAt(i) != B.charAt(i + j)) {
						result ++;
					}
				}
				resultList.add(result);
				result = 0;
				j++;
			}
			// 배열 요소 탐색
			for (int num : resultList) {
				if (num < min) {
					min = num;
				}
			}
			System.out.println(min);
		}
	}
}

```



### 17252. 삼삼한 수

```java
import java.util.Scanner;

public class Baekjoon17252 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		
		int N = sc.nextInt();
		
		Boolean check = false;
		
		if (N == 0) {
			System.out.println("NO");
		}
		
		else {
			while (N > 0) {
				// N의 나머지가 2 이상이면 거듭제곱 수 중복
				if (N % 3 > 1) {
					System.out.println("NO");
					check = true;
					break;
				}
				N = N / 3;
			}
			if (check == false) {
				System.out.println("YES");
			}
		}
	}
}

```



### 1865. 웜홀

```python
```



### 2069. 보이는 산맥

```python
# 2069. 보이는 산맥

# N개의 산봉우리
N = int(input())

arr = []

# 꼭지점의 좌표
for _ in range(N):

    x_left, x_right = map(int, input().split())

    line = []

    for j in range(1):
        line.append(x_left)
        line.append(x_right)
    arr.append(line)

# 산맥이 가림 (가려진 산맥의 밑변의 길이)
checkList = [0] * (N - 1)

for i in range(N - 1):
    if arr[i][1] > arr[i+1][0]:
        checkList[i] = abs(arr[i][1] - arr[i+1][0])

# 모든 산맥의 면적 구하기
area = 0
for moun in arr:
    # 밑변의 길이
    x = moun[1] - moun[0]
    # 높이
    h = x * 2
    # 넓이
    a = (x * h) // 2

    area += a

# 가려진 산맥의 넓이 구하기
hide_area = 0
for hide_x in checkList:
    # 높이
    hide_h = hide_x * 2
    # 넓이
    hide_a = (hide_x * hide_h) // 2

    hide_area += hide_a

print(area - hide_area)

```



### 13132. World Cup

```python
```



### 1799. 비숍

```python
```





## [10회차] 210930

### 1405. 미친로봇

```python
# 1405. 미친 로봇
d = [(-1, 0), (1, 0), (0, -1), (0, 1)]


def dfs(x, y, visited, total):
    global answer
    if len(visited) == N + 1:
        answer += total
        return

    for k in range(4):
        nx = x + d[k][0]
        ny = y + d[k][1]

        if (nx, ny) not in visited:
            visited.append((nx, ny))
            dfs(nx, ny, visited, total * probability[k])
            visited.pop()


N, e, w, s, n = map(int, input().split())

probability = [e, w, s, n]

answer = 0

dfs(0, 0, [(0, 0)], 1)

print(answer * (0.01 ** N))

```



### 2225. 합분해

`1차원 배열`

```python
# 2225. 합분해

# 한 개의 수를 여러 번 쓸 수 있다.
# 순서가 바뀐 경우는 다른 경우이다.

N, K = map(int, input().split())

# 0부터 N까지 K개 더해서 합이 N이 되는 경우 모두 구하기
answer = 0

dp = [1]

dp += [0] * N

mod = 1000000000

for _ in range(1, K + 1):
    for idx in range(1, N + 1):
        dp[idx] = (dp[idx] + dp[idx - 1]) % mod

print(dp[N])

```

`2차원 배열`

```python
import sys
sys.stdin = open('2.txt', 'r')
'''
1405 / 2225 / 1504 / 1516 / 2136
'''


# 2225. 합분해

# 한 개의 수를 여러 번 쓸 수 있다.
# 순서가 바뀐 경우는 다른 경우이다.

N, K = map(int, input().split())

# 0부터 N까지 K개 더해서 합이 N이 되는 경우 모두 구하기
answer = 0

dp = [[0] * 201 for i in range(201)]

mod = 1000000000

for i in range(201):
    dp[1][i] = 1
    dp[2][i] = i + 1

for i in range(2, 201):
    dp[i][1] = i
    for j in range(2, 201):
        dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % mod

print(dp[K][N])

```



## [11회차] 211007

### 15686. 치킨 배달

```python
from itertools import combinations

# G5. 15686. 치킨 배달

# 0 : 빈 칸 / 1 : 집 / 2 : 치킨집

N, M = map(int, input().split())

city = [list(map(int, input().split())) for _ in range(N)]

# 폐업 시키지 않을 치킨집을 최대 M개 골랐을 때, 도시의 치킨 거리의 최솟값 출력
home = []
chicken = []

for i in range(N):
    for j in range(N):
        if city[i][j] == 1:
            home.append([i, j])
        elif city[i][j] == 2:
            chicken.append([i, j])

arr = list(combinations(chicken, M))
length = 9999

for chi in arr:
    last = 0
    for h in home:
        check1 = 9999
        for c in chi:
            if check1 > abs(h[0] - c[0]) + abs(h[1] - c[1]):
                check1 = abs(h[0] - c[0]) + abs(h[1] - c[1])
        last += check1

    if length > last:
        length = last

print(length)

```

### 3933. 라그랑주의 네 제곱수 정리

```python
import math
# 3933. 라그랑주의 네 제곱수 정리

while True:
    N = int(input())
    if N == 0:
        break

    cnt = 0

    n = int(math.sqrt(N))

    for i in range(1, n + 1):
        if i ** 2 == N:
            cnt += 1

        for j in range(i, n + 1):
            if i ** 2 + j ** 2 == N:
                cnt += 1
            elif i ** 2 + j ** 2 > N:
                break

            for k in range(j, n + 1):
                if i ** 2 + j ** 2 + k ** 2 == N:
                    cnt += 1
                elif i ** 2 + j ** 2 + k ** 2 > N:
                    break

                for l in range(k, n + 1):
                    if i ** 2 + j ** 2 + k ** 2 + l ** 2 == N:
                        cnt += 1
                    elif i ** 2 + j ** 2 + k ** 2 + l ** 2 > N:
                        break

    print(cnt)

```



## [12회차] 211014

### 16172.  나는 친구가 적다 (예제는 맞지만 왜 틀린지 모름)

```python
# G3. 16172. 나는 친구가 적다 (Large)
'''
KMP 알고리즘
1. pi 배열
- pi 배열 = 찾을 문자열의 길이 만큼의 배열
- pi의 idx번째 배열에 저장하는 값 = 접두사와 접미사가 일치할 때 접두사가 j번째 까지라면 j + 1을 pi[idx]에 저장
- 예시1) aaaab = [0, 1, 2, 3, 0] abcabd = [0, 0, 0, 1, 2, 0]

pi 배열을 만들면 비교 문자열과 비교했을 때 일치하는 패턴이 0부터 k-1번째 까지 있으면 k번째부터 비교하면 된다. (k-1번째 까지는 이미 일치하는 것을 알고있음)
        0 1 2 3 4 5 6 = idx
2.  S = a a a a a b b
                0 1 2 3 4 = idx
    substring이 a a a a b 일 때

KMP
S = a a a a a b b   idx = 4에서 불일치이므로 s의 pi 배열에서 불일치한 idx - 1, pi[idx-1]의 값을 알아내고 그 값의 문자 s[pi[idx - 1]] 부터 다시 비교한다.
s = a a a a b

만약 pi[idx - 1]이 0이면 처음부터 비교해야한다.   
'''
def getPI(pattern):
    j = 0
    n = len(pattern)

    for i in range(1, n):
        while j > 0 and pattern[i] != pattern[j]:
            j = pi[j - 1]

        # pi값 찾기
        if pattern[i] == pattern[j]:
            j += 1
            pi[i] = j

    return pi


def KMP(S, pattern):
    pi = getPI(pattern)
    j = 0

    n = len(S)
    m = len(pattern)

    for i in range(n):
        while j > 0 and S[i] != pattern[j]:
            j = pi[j - 1]
        if S[i] == pattern[j]:
            if j == m - 1:
                return True
            else:
                j += 1
    return False


S = list(input())

K = list(input())

erase = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']

for s in S:
    if s in erase:
        S.remove(s)


pi = [0] * len(K)

if KMP(S, K):
    print(1)
else:
    print(0)

```



### 1727. 커플 만들기

```python
b, g = map(int, input().split())


# l : 인원이 적은 성별 / m : 인원이 많은 성별
l, m = [], []

# b(남자) g(여자) 에서 항상 g가 많다고 설정
if b > g:
    m = sorted(list(map(int, input().split())))
    l = sorted(list(map(int, input().split())))

    swap = b
    b = g
    g = swap

else:
    l = sorted(list(map(int, input().split())))
    m = sorted(list(map(int, input().split())))

dp = [[0] * 1001 for _ in range(1001)]

dp[0][0] = abs(l[0] - m[0])     # 첫번째 남자가 첫번째 여자 선택

for i in range(b):
    # 첫 번째 남자의 선택
    if i == 0:
        # 선택할 수 있는 최대 범위까지
        for j in range(1, g - (b - i - 1)):
            dp[i][j] = min(dp[i][j - 1], abs(l[0] - m[j]))  # 현재 선택한 여자와 이전의 선택한 여자 중 최솟값 저장

    # 두 번째 남자부터 선택
    else:
        for j in range(i, g - (b - i - 1)):
            if j == i:  # 두 번째 남자가 두 번째 여자 골랐을 때
                # 첫 번째 남자가 첫 번째 여자 골랐을 때를 더해준다
                dp[i][j] = dp[i - 1][j - 1] + abs(l[i] - m[j])
            else:
                # 두 번째 남자와 세 번째 여자가 만났을 때
                # 2남-3여의 절대값을 구하여서 dp[1][2]에 더하고
                # dp[2][2]와 비교하여 최솟값을 구한다.
                dp[i][j] = min(dp[i - 1][j - 1] + abs(l[i] - m[j]), dp[i][j - 1])

print(dp[b - 1][g - 1])

```

### 2551. 두 대표 자연수

```python
# 조건을 빼먹은거 같다. 왜 틀렸는 지 모르겠다.
N = int(input())

n = sorted(list(map(int, input().split())))

a = n[(N-1)//2]

b = round(sum(n)/N)
print(a, b)
```



## [13회차] 211018

### 1965. 상자넣기

```python
n = int(input())

box = list(map(int, input().split()))

# 상자의 크기가 작으면 큰 상자에 들어간다.
dp = [1] * (n + 1)  # 1개 담는걸로 초기화

for i in range(1, n):
    for j in range(i):
        # 현재 위치(i) 앞에 있는 상자와 비교
        if box[i] > box[j]:
            # i 이전 위치에서 최댓값을 찾고 찾은 값 + 1
            dp[i] = max(dp[i], dp[j] + 1)

print(max(dp))
```

### 이친수 찾기

```python
R, C = map(int, input().split())
arr = []
arduino = []
for i in range(R):
    row = list(input())
    for j in range(C):
        if row[j] == 'I':
            start = (i, j)
        elif row[j] == 'R':
            arduino.append((i, j))
    arr.append(row)

info = input()
l = len(info)
cnt = 0
move = [(), (1, -1), (1, 0), (1, 1), (0, -1), (0, 0), (0, 1), (-1, -1), (-1, 0), (-1, 1)]
for i in range(l):
    save = True
    r, c = start
    dr, dc = move[int(info[i])]
    nr, nc = r + dr, c + dc
    cnt += 1
    nxt_arduino = set()
    break_arduino = []
    for r, c in arduino:
        if r < nr:
            r += 1
        elif nr < r:
            r -= 1
        if c < nc:
            c += 1
        elif nc < c:
            c -= 1
        if (r, c) in nxt_arduino:
            break_arduino.append((r, c))
        nxt_arduino.add((r, c))

    if (nr, nc) in nxt_arduino:
        print("kraj {}".format(cnt))
        save = False
        break

    for ard in break_arduino:
        nxt_arduino.discard(ard)
    arduino = list(nxt_arduino)

    start = (nr, nc)

if save:
    final = [['.'] * C for _ in range(R)]
    final[start[0]][start[1]] = 'I'
    for r, c in arduino:
        final[r][c] = 'R'

    for i in range(R):
        print(''.join(final[i]))
```



## [14회차] 211108

### 4811. 알약

```python
# 4811. 알약

while True:
    N = int(input())

    if N == 0:
        break

    dp = [[0] * (N + 1) for _ in range(N + 1)]

    # 초기조건 : 알약을 한 개 먹는 경우
    for i in range(1, N + 1):
        dp[0][i] = 1

    # dp[i][j] : 약 반 쪽을 i번, 한 개를 j번 먹었을 때

    for i in range(1, N + 1):
        for j in range(i, N + 1):
            dp[i][j] += dp[i-1][j] + dp[i][j-1]

    print(dp[N][N])
```



### 1939. 중량제한

```python
# 1939. 중량제한
from collections import deque


def bfs(mid):
    q = deque()
    q.append(start)

    visited = set()
    visited.add(start)

    result = []

    while q:
        A = q.popleft()
        for B, C in country[A]:
            # 연결되어 있으면서 중량제한에 걸리지 않음
            if B not in visited and C >= mid:
                visited.add(B)
                q.append(B)

    # 도착지점을 방문할 수 있는 경우면 True, 아니면 False
    if end in visited:
        return True
    else:
        False


# N : 섬의 개수 / M : 다리의 개수
N, M = map(int, input().split())

country = [[] for _ in range(N + 1)]

for _ in range(M):
    # A번과 B번 섬 사이의 중량제한이 C인 다리
    A, B, C = map(int, input().split())

    # 각 도시의 연결 여부와 무게제한 저장
    country[A].append((B, C))
    country[B].append((A, C))

# 공장이 위치한 섬의 번호
start, end = map(int, input().split())

# 통과할 수 있는 중량의 최소, 최대
_min = 1
_max = 1000000000

# 이분탐색으로 최댓값 찾기
result = _min

while _min <= _max:
    mid = (_min + _max) // 2

    # 해당 무게로 start -> end까지 도착이 가능한 경우
    if bfs(mid):
        result = mid # 값 저장 후
        _min += 1 # 최댓값 구하기 위해 _min 증가
    else:
        _max = mid - 1

print(result)

```



### 8982. 수족관 1

```python
```



## [15회차] 211118

### 1713. 후보 추천하기

```python
# 1713. 후보 추천하기

# 사진틀의 개수
N = int(input())

# 총 추천 횟수
totalVote = int(input())

# 추천받은 학생을 나타내는 번호
getVote = list(map(int, input().split()))

# 사진틀
pic = {}

for i in range(totalVote):
    # 이미 사진틀에 있는 후보일 때
    if getVote[i] in pic:
        pic[getVote[i]][0] += 1 # 득표수만 증가

    else:
        # 사진틀 채우기
        if len(pic) < N:
            # key : 후보자 번호 / value : [득표수, 액자에 걸린 순서]
            pic[getVote[i]] = [1, i]

        # 사진틀 꽉참
        else:
            # 득표수 가장 적은 사람 & 먼저 들어온 사람 정렬
            _list = sorted(pic.items(), key=lambda x: (x[1][0], x[1][1]))
            # 가장 적은 후보 (중복이라면 가장 먼저 들어온 사람) 찾기
            _key = _list[0][0]
            # 삭제
            del pic[_key]
            pic[getVote[i]] = [1, i]    # 추가

ans = sorted(pic.items(), key=lambda x: x[1][0])

# 득표순 정렬
ans.sort(reverse=False)

result = []

for i in ans:
    result.append(i[0])

print(*result)

```



### 9547. 대통령 선거

```python
# 1612. 가지고 노는 1

T = int(input())

for tc in range(1, T + 1):

    C, V = map(int, input().split())

    vote = {}   # 유권자의 선호도

    total = [0] * (C + 1)  # 득표 현황

    day = 1 # 회차

    for v in range(1, V + 1):
        vote[v] = 0

    for v in range(1, V + 1):
        vote[v] = list(map(int, input().split()))


    # 투표하기
    for value in vote.values():
        total[value[0]] += 1


    _max = max(total)   # 최고 득표

    # 첫번째 투표에서 과반수 획득
    if _max > V // 2:
       print(total.index(_max), day)

    else:
        day += 1

        people = []

        for idx, v in enumerate(total):
            people.append((idx, v))

        people.sort(key= lambda x: x[1], reverse=True)

        last = []   # 최종후보 두 명
        last.append(people[0][0])
        last.append(people[1][0])

        final_vote = {} # 최종 투표

        for v in last:
            final_vote[v] = 0

        # 최종 후보자 투표
        for value in vote.values():

            for i in range(len(value)):
                if value[i] in last:
                    final_vote[value[i]] += 1
                    break


        a = max(final_vote, key=final_vote.get)	# value가 최대인 key값 구하기

        # pick2 = sorted(final_vote.items(), key=lambda item: item[1], reverse=True)

        print(a, day)
```



### 6571. 피보나치 수의 개수

```python
# 6571. 피보나치 수의 개수

fibo = [0] * 1001

fibo[1] = 1
fibo[2] = 2

for i in range(3, 1001):
    fibo[i] = fibo[i - 1] + fibo[i - 2]

while True:
    a, b = map(int, input().split())

    if a == 0 and b == 0:
        break

    answer = 0

    for i in range(1, 1001):
        if a <= fibo[i] and fibo[i] <= b:
            answer += 1

    print(answer)
```





### 1309. 동물원

```python
# 1309. 동물원
n = int(input())
dp = [1,3] + [0]*(n-1)
for i in range(2,n+1):
    dp[i] = (dp[i-2] + dp[i-1]*2)%9901
print(dp[n])
```



## [16회차] 211202

### 1011. Fly me to the Alpha Centauri

> https://mjeong9316.tistory.com/147

```python
import math

# 1011. Fly me to the Alpha Centauri
T = int(input())

for tc in range(1, T + 1):
    x, y = map(int, input().split())

    # y지점에 도착하기 바로 직전의 이동거리는 1광년

    m = int(math.sqrt(y - x))

    # y - x가 제곱수 일 때의 이동횟수
    if y - x == m * m:
        print(2 * m - 1)

    # 제곱수 아닐 때 이동횟수
    elif m * m < (y - x) and y - x <= m * m + m:
        print(2 * m)
    else:
        print(2 * m + 1)

```



### 21608. 상어초등학교

> https://deok2kim.tistory.com/328

```python
# 21608. 상어초등학교
'''
1. 좋아하는 학생이 인접한 칸에 가장 많은 칸
2. 1을 만족하는 칸 여러개 = 인접 칸 중 비어있는 칸 많은 곳
3. 2를 만족하는 칸도 여러개 = 행 -> 열 번호가 가장 작은 칸
'''

N = int(input())

favor = {}  # 학생과 선호학생 딕셔너리

for i in range(N * N):
    student, *like = map(int, input().split())

    favor[student] = like

_class = [[0] * N for _ in range(N)]    # 교실

dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

# 학생 배치
for student, like in favor.items():
    max_like = 0    # 조건1
    max_blank = 0   # 조건2
    location = -1, -1

    for i in range(N):
        for j in range(N):
            # 자리가 비어있을 때만
            if _class[i][j] != 0:
                continue

            if location == (-1, -1):
                location = i, j # 처음 나오는 빈자리

            like = 0
            blank = 0

            for k in range(4):
                nx = i + dx[k]
                ny = j + dy[k]

                # 범위 조건
                if 0 <= nx < N and 0 <= ny < N:

                    # 빈자리일 때
                    if _class[nx][ny] == 0:
                        blank += 1

                    # 해당 자리가 좋아하는 학생의 자리일 때
                    elif _class[nx][ny] in favor[student]:
                        like += 1

            # 조건 충족
            if like > max_like or (like == max_like and blank > max_blank):
                max_like = like
                max_blank = blank
                location = i, j

    x, y = location
    _class[x][y] = student

# 점수 계산
total = 0
score = [0, 1, 10, 100, 1000]

for i in range(N):
    for j in range(N):
        student = _class[i][j]
        like = 0

        for k in range(4):
            nx = i + dx[k]
            ny = j + dy[k]

            if 0 <= nx < N and 0 <= ny < N:
                if _class[nx][ny] in favor[student]:
                    like += 1

        total += score[like]

print(total)

```



### 16235. 나무 재테크

```python
from collections import deque
# 16235. 나무 재테크

# 봄
# 1. 자신의 나이만큼 양분을 먹고, 나이 1 증가
# 2. 8방향 칸에 있는 양분만 먹음
# 3. 한 칸에 여러 개의 나무 = 나이가 어린 나무부터 (양분이 부족하면 죽음)
def spring():
    for i in range(N):
        for j in range(N):
            _len = len(land[i][j])  # 칸마다 심어져있는 나무의 수

            for k in range(_len):
                if land[i][j][k] <= first[i][j]: # 양분이 더 많을 때
                    first[i][j] -= land[i][j][k]  # 양분 감소
                    land[i][j][k] += 1  # 나이 1 증가

                else:   # 양분이 부족할 때 -> 나무 죽음
                    for _ in range(k, _len):    # 양분이 부족한 나무부터 끝 나무까지
                        # 여름
                        # 1. 봄에 죽은 나무가 양분으로 변함 (나이의 절반)
                        # 2. appendleft로 어린 나무를 추가해주었기 때문에 뒤에는 무조건 부족
                        first[i][j] += (land[i][j].pop() // 2)
                    break

# 가을
# 1. 나무가 번식
# 2. 번식하는 나무는 나이가 5의 배수이며 인접한 8개의 칸에 나이가 1인 나무가 생김
dx = [-1, -1, -1, 0, 0, 1, 1, 1]
dy = [-1, 0, 1, -1, 1, -1, 0, 1]


def fall():
    for i in range(N):
        for j in range(N):
            for k in land[i][j]:
                if k % 5 == 0:  # 나이가 5의 배수
                    for l in range(8):
                        nx = i + dx[l]
                        ny = j + dy[l]

                        if 0 <= nx < N and 0 <= ny < N:
                            land[nx][ny].appendleft(1)  # 어린 나무 심기
            # 겨울
            # 양분 보충
            first[i][j] += add[i][j]


N, M, K = map(int, input().split()) # N : 땅의 크기 /  K : 년도

add = [list(map(int, input().split())) for _ in range(N)]   # 각 칸마다 추가되는 양분

land = [[deque() for _ in range(N)] for _ in range(N)]  # 땅

first = [[5 for _ in range(N)] for _ in range(N)]   # 초기 양분

cnt = 0 # 살아있는 나무의 수

for _ in range(M):
    x, y, z = map(int, input().split()) # x, y : 좌표 / z : 나이

    land[x - 1][y - 1].append(z)    # 나무 심기 (값은 나이)

# 봄 가을 과정
for _ in range(K):
    spring()
    fall()

for i in range(N):
    for j in range(N):
        cnt += len(land[i][j])

print(cnt)

```

### 2668. 숫자고르기

```python
from collections import deque

# 2668. 숫자고르기
def dfs(num):
    global ans

    q = deque()
    q.append(num)
    visited = [False] * (N + 1)

    while q:
        next = dic[q.popleft()] # 둘째 줄 정수

        # cycle 만족
        if next == num:
            ans.append(num)
            return

        if visited[next] == False:
            q.append(next)
            visited[next] = True


N = int(input())

dic = {}

ans = []

for i in range(1, N + 1):
    dic[i] = int(input())

# cycle 찾기
for num in dic:
    dfs(num)

print(len(ans))

for n in ans:
    print(n)

```



## [17회차] 211209

### 20157. 화살을 쏘자!

> 처음 방법 : Fraction을 이용하여 분수 자체로 비교 => 길이가 길어지면 유한소수 = 무한소수를 같은 기울기로 비교하기 때문에 오답
>
> 방법 : 최대공약수로 나눈 두 수를 key로 저장하여 좌표 자체로 기울기 비교
>
> 80%에서 틀림 (왜 틀렸을까?)

```python
# 20157. 화살을 쏘자!
from math import gcd

N = int(input())

x_cnt, y_cnt = 0, 0 # x or y가 0일 때

nums = []

list_gradient = []

dict_gradient = {}

for _ in range(N):
    x, y = map(int, input().split())

    if x != 0 and y != 0:
        # 두 수의 최대 공약수 구하기
        _gcd = gcd(x, y)

        nx, ny = x // _gcd, y // _gcd

        list_gradient.append((nx, ny))

        dict_gradient[(nx, ny)] = 0

    # x = 0
    if x == 0:
        x_cnt += 1

    # y = 0
    if y == 0:
        y_cnt += 1

# 같은 기울기 찾기
for gradient in list_gradient:
    dict_gradient[gradient] += 1

values = dict_gradient.values()

max_value = max(values)

# 값 비교
result = []

result.append(x_cnt)
result.append(y_cnt)
result.append(max_value)

print(max(result))

```



> x = 0, y = 0일 때 양수 / 음수 조건을 파악하지 않았다!

```python
# 20157. 화살을 쏘자!
import sys
from math import gcd

N = int(input())

x_plus, x_minus, y_plus, y_minus = 0, 0, 0, 0 # x or y가 0일 때

dict_gradient = {}

for _ in range(N):
    x, y = map(int, sys.stdin.readline().split())

    if x != 0 and y != 0:
        # 두 수의 최대 공약수 구하기
        _gcd = gcd(x, y)

        nx, ny = x // _gcd, y // _gcd

        dict_gradient[(nx, ny)] = dict_gradient.get((nx, ny), 0) + 1

    # x = 0, y > 0
    if x == 0 and y > 0:
        y_plus += 1

    # x = 0, y < 0
    if x == 0 and y < 0:
        y_minus += 1

    # y = 0, x > 0:
    if x > 0 and y == 0:
        x_plus += 1

    # y = 0, x < 0:
    if x < 0 and y == 0:
        x_minus += 1

values = dict_gradient.values()

max_value = max(values)

# 값 비교
result = []

result.append(x_plus)
result.append(x_minus)
result.append(y_plus)
result.append(y_minus)
result.append(max_value)

print(max(result))

```

> 정답 수정
>
> : gcd에서는 0일 때를 구분 하지 않아도 된다.
>
> fraction 때문에 0인 조건을 넣었었다가 수정했기 때문에 코드가 복잡해졌다.

```python
# 20157. 화살을 쏘자!
import sys
from math import gcd

N = int(input())

dict_gradient = {}

for _ in range(N):
    x, y = map(int, sys.stdin.readline().split())

    _gcd = gcd(x, y)

    nx, ny = x // _gcd, y // _gcd

    dict_gradient[(nx, ny)] = dict_gradient.get((nx, ny), 0) + 1


values = dict_gradient.values()

max_value = max(values)

print(max_value)

```



### 17425. 약수의 합

> 시간초과 풀이

```python
# 17425. 약수의 합
def get_prime(num):
    # True : 소수
    check_prime = [False, False] + [True] * (N - 1)

    n = int(num ** 0.5)

    for i in range(2, n + 1):
        if check_prime[i]:

            # 다음 숫자 부터 배수 판정
            for j in range(i + i, num + 1, i):
                check_prime[j] = False

    return check_prime[num]


# 소수가 아닐 때 약수의 합 구하기
def get_divisor(num):
    divisor = 0

    n = num // 2

    for i in range(1, n + 1):
        if num % i == 0:
            divisor += i
    divisor += num

    return divisor


T = int(input())

for tc in range(1, T + 1):
    N = int(input())

    # f(y) : 자연수 y의 모든 약수의 합
    y = N

    # g(N) 구하기 [N >= y 를 만족하는 모든 f(y)들의 합]
    g_N = 1

    while y > 1:
        # 자연수 y가 소수일 때
        if get_prime(y):
            g_N += (y + 1)

        # 자연수 y가 소수가 아닐 때
        else:
            g_N += get_divisor(y)

        y -= 1

    print(g_N)
```

> 오답 코드 (배수의 원리 이용 X)
>
> 원리
>
> 1. N의 배수는 항상 N을 약수로 갖는다.
> 2. 그러므로 N이하의 자연수 중에서 i를 약수를 갖는 개수는 N / i개
> 3. 그 개수에 약수만 곱하면 된다.

```python
# 17425. 약수의 합
T = int(input())

for tc in range(1, T + 1):
    N = int(input())

    g_N = 0

    for i in range(1, N + 1):
        g_N += (N // i) * i

    print(g_N)

```



> 정답 코드(배수의 원리)
>
> * readline으로 시간 초과 해결

```python
# 17425. 약수의 합
import sys

T = int(input())

_max = 1000000  # 자연수의 최댓값

dp = [1] * (_max + 1)   # dp[i] = 자연수 i의 모든 약수의 합

_sum = [0] * (_max + 1) # _sum[i] = 1부터 i까지 약수들의 합

for i in range(2, _max + 1):
    j = 1
    
    # i부터 max 까지 i의 배수인 부분에 i를 더해준다.
    while i * j <= _max:
        dp[i * j] += i
        j += 1

for i in range(1, _max + 1):
    _sum[i] = _sum[i - 1] + dp[i]

for tc in range(1, T + 1):
    N = int(sys.stdin.readline())    # N : 자연수

    print(_sum[N])
```



### 2590. 색종이

> 시간초과

```python
# 2590. 색종이

paper = {i: 0 for i in range(1, 7)} # key : 색종이 번호 / value : 색종이 장수(100개 최대)

for i in range(1, 7):
    paper[i] = int(input())

board = 0

# 1. 6cm 색종이 사용
board = paper[6]

# 2. 5cm 색종이 사용
while paper[5] != 0:

    board += 1  # 판 추가

    paper[5] -= 1   # 5cm 색종이 사용

    # 1cm 색종이 11개 이상이라면 판 꽉 채우기
    if paper[1] >= 11:
        paper[1] -= 11

    else:
        # 11개 미만이라면 모두 사용
        paper[1] = 0

# 3. 4cm 색종이 사용
while paper[4] != 0:

    board += 1  # 판 추가

    paper[4] -= 1   # 4cm 색종이 사용

    # 2cm 색종이 5개 이상이라면 판 꽉 채우기
    if paper[2] >= 5:
        paper[2] -= 5

    else:
        paper[2] = 0

# 4. 3cm 색종이 사용
while paper[3] != 0:

    # 3cm 색종이가 4개 이상이라면
    if paper[3] >= 4:

        # 4개씩 사용해서 한 판 채우기
        paper[3] -= 4
        board += 1

    else:
        # 3cm 3장일 때
        if paper[3] == 3:
            paper[3] = 0

            # 2cm 종이 꽉채우기
            paper[2] = max(paper[2] - 1, 0)

            board += 1

        # 3cm 2장일 대
        elif paper[3] == 2:
            paper[3] = 0

            # 2cm 3개
            paper[2] = max(paper[2] - 3, 0)

            board += 1

        # 3cm 1장일 때
        elif paper[3] == 1:
            paper[3] = 0

            # 2cm 5개
            paper[2] = max(paper[2] - 5, 0)

            board += 1

# 5. 2cm 색종이 사용
while paper[2] != 0:

    # 2cm 색종이가 9개 이상이면
    if paper[2] >= 9:

        # 9개 사용해서 한 판 채우기
        paper[2] = max(paper[2] - 9, 0)

        board += 1

# 6. 1cm 색종이 사용
while paper[1] != 0:
    paper[1] = max(paper[1] - 36, 0)
    board += 1

print(board)

```

> 정답코드
>
> 면적의 개념 도입

```python
# 2590. 색종이

paper = {i: 0 for i in range(1, 7)} # key : 색종이 번호 / value : 색종이 장수(100개 최대)

for i in range(1, 7):
    paper[i] = int(input())

board = 0   # 사용한 판의 개수

# 1. 6cm 색종이 사용
board = paper[6]

# 2. 5cm 색종이 사용
while paper[5] > 0:
    area = 36   # 판의 총 면적

    paper[5] -= 1   # 5cm 색종이 사용

    area -= 25 # 색종이 붙일 수 있는 면적 감소

    # 남은 면적 1cm 종이로 채우기
    if paper[1] > area:
        paper[1] -= area
    # 면적보다 적다면 모두 사용
    else:
        paper[1] = 0

    board += 1  # 판 추가

# 3. 4cm 색종이 사용
while paper[4] > 0:
    area = 36

    paper[4] -= 1   # 4cm 색종이 사용

    area -= 16  # 색종이 붙일 수 있는 면적 감소

    # 2cm 색종이 붙이기 (최대 다섯장 붙일 수 있다.)
    if paper[2] > 5:
        paper[2] -= 5   # 5장 붙이기
        area -= 20  # 면적 감소
    else:
        # 5장 보다 적다면 남아있는 2cm 모두 색종이 붙인다.
        area -= (4 * paper[2])
        paper[2] = 0

    # 1cm 색종이 붙이기
    if paper[1] > area:
        paper[1] -= area
    # 면적보다 적다면 모두 사용
    else:
        paper[1] = 0

    board += 1

# 4. 3cm 색종이 사용
while paper[3] > 0:
    area = 36

    # 3cm 색종이가 4개 이상이라면
    if paper[3] > 4:
        paper[3] -= 4   # 4장 모두 붙이기
        area = 0    # 면적 꽉참
    else:
        # 남아있는 색종이 모두 붙이기
        area -= (9 * paper[3])
        paper[3] = 0

    # 3cm 색종이를 모두 붙이고 남은 면적이 있다면

    # 3cm 색종이 1장 붙였을 때 (남은 면적 27)
    if area == 27:
        if paper[2] > 5:
        # 2cm 종이가 5장 이상 있을 때
            area -= 20
            paper[2] -= 5   # 5장 사용
        else:
            area -= (4 * paper[2])
            paper[2] = 0

    # 3cm 색종이 2장 붙였을 때 (남은 면적 18)
    if area == 18:
        if paper[2] > 3:
        # 2cm 종이가 3장 이상 있을 때
            area -= 12
            paper[2] -= 3   # 3장 사용
        else:
                area -= (4 * paper[2])
                paper[2] = 0

    # 3cm 색종이 3장 붙였을 때 (남은 면적 9)
    if area == 9 and paper[2] >= 1:
            area -= 4
            paper[2] -= 1 # 1장 사용

    # 1cm 색종이 사용
    if paper[1] > area:
        paper[1] -= area
    # 면적보다 적다면 모두 사용
    else:
        paper[1] = 0

    board += 1


# 5. 2cm 색종이 사용
while paper[2] > 0:
    area = 36

    # 2cm 종이가 9개 이상일 때
    if paper[2] > 9:
        area = 0
        paper[2] -= 9
    else:
        area -= (4 * paper[2])
        paper[2] = 0

    # 1cm 색종이 사용
    if paper[1] > area:
        paper[1] -= area
    # 면적보다 적다면 모두 사용
    else:
        paper[1] = 0

    board += 1

# 6. 1cm 색종이 사용
while paper[1] > 0:
    area = 36

    if paper[1] > 36:
        paper[1] -= 36
    else:
        paper[1] = 0

    board += 1

print(board)

```





### 1613. 역사

> 플로이드-와샬
>
> for k for i for j / if i == j / ijk

```python
# 1613. 역사

n, k = map(int, input().split()) # n : 사건의 개수 / k : 전후 관계의 개수

case = [[0] * n for _ in range(n)]  # 사건 관계 그래프

for _ in range(k):
    before, after = map(int, input().split())   # 이전 사건 / 이후 사건

    case[before - 1][after - 1] = 1

s = int(input())    # 전후 관계를 알고 싶은 사건 쌍의 수

# 플로이드-와샬
for k in range(n):
    for i in range(n):
        for j in range(n):
            # 사건 i가 k보다 먼저 일어나고 사건 k가 j보다 먼저 일어났다면
            if case[i][k] == 1 and case[k][j] == 1:
                # 사건 i가 j보다 먼저 일어났다
                case[i][j] = 1

# s개의 쌍 확인
# know1이 know2보다
# (1)먼저 일어나면 -1, (2)늦게 일어나면 1, (3)모르면 0 출력
for _ in range(s):
    know1, know2 = map(int, input().split())

    # (1)
    if case[know1 - 1][know2 - 1] == 1:
        print(-1)
    # (2)
    elif case[know2 - 1][know1 - 1] == 1:
        print(1)
    # (3)
    else:
        print(0)

```



## [18회차] 211216

### 14500. 테트로미노

```python
# 14500. 테트로미노
import sys

N, M = map(int, input().split())

paper = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]

visited = [[False] * M for _ in range(N)]

_max = 0    # 'ㅜ' 모양 제외 테트로미노의 최댓값

ans = 0 # 'ㅜ' 모양의 최댓값


# 'ㅜ' 모양 제외 테트로미노
def dfs(x, y, _sum, _len):
    global _max

    if _len == 4:   # 테트로미노가 됐을 때
        if _sum > _max:
            _max = _sum
        return

    for k in range(4):
        nx = x + dx[k]
        ny = y + dy[k]

        if 0 <= nx < N and 0 <= ny < M and visited[nx][ny] == False:
            visited[nx][ny] = True

            dfs(nx, ny, _sum + paper[nx][ny], _len + 1)

            visited[nx][ny] = False


# 'ㅜ' 모양 테트로미노
def one(x, y):
    global _max, ans

    for i in range(4):
        ans = paper[x][y]   # 밑 도형(ㅡ 모양) 의 가운데 부분을 기준

        for j in range(3):  # 기준 점에서 3 방향으로의 전환으로 'ㅜ' 모양 만들기
            k = (i + j) % 4

            nx = x + dx[k]
            ny = y + dy[k]

            if 0 <= nx < N and 0 <= ny < M and visited[nx][ny] == False:
                ans += paper[nx][ny]

            else:
                ans = 0
                break   # 다른 모양 확인

        # 'ㅜ' 모양 완성 후 값 비교
        _max = max(_max, ans)

    return _max


dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

for x in range(N):
    for y in range(M):
        visited[x][y] = True    # dfs에서 모양 생성할 때 초기값 반복 차단

        # 'ㅜ'을 제외한 테트로미노는 4방향 탐색으로 모양 만들기 가능
        dfs(x, y, 0, 0) # x, y, _sum, _len

        visited[x][y] = False

        one(x, y)   # 'ㅜ' 모양

print(_max)

```



### 2344. 거울

> 처음에 대칭 구조인 줄 알고 절반만 구해서 딕셔너리를 뒤집었지만
>
> 절반 중 이동하지 않는 구멍이 생길 경우 keyerror가 나서 모든 방향에 대해 구현하였다.

```python
# 2344. 거울
import sys

N, M = map(int, input().split())

table = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]

box = [[0] * (M + 2) for _ in range(N + 2)] # 번호가 적혀있는 구멍을 만들어줌

for i in range(N):
    for j in range(M):
        if table[i][j] == 1:
            box[i + 1][j + 1] = -2  # 거울을 -2로 교체

# 좌측 번호 입력
for i in range(1, N + 1):
    box[i][0] = i

# 하단 번호 입력
n = N + 1
for i in range(1, M + 1):
    box[N + 1][i] = n
    n += 1

# 우측 번호 입력
right_num = n
for i in range(N, 0, -1):
    box[i][M + 1] = n
    n += 1

# 상단 번호 입력
up_num = n
for i in range(M, 0, -1):
    box[0][i] = n
    n += 1

mirror = {i: 0 for i in range(1, (2 * N + 2 * M) + 1)}

# 빛의 진행방향
# 1 ~ N 까지 : 오른쪽 y += 1 => 거울을 만나면 위로 x -= 1 (범위를 벗어나면 그 방향으로 나옴)
# N + 1 ~ (2N + 2M) // 2 : 위로 x -= 1 => 거울을 만나면 오른쪽으로 y += 1

# 왼쪽 번호 탐색 (가능한 방향 위, 오른쪽)
for i in range(1, N + 1):
    up, right, direct = i, 1, True  # True : 오른쪽 유지, False : 위쪽 유지

    while mirror[i] == 0:
        if box[up][right] == 0: # 거울이 아닐 때
            if direct == True:
                right += 1

            else:
                up -= 1

        if box[up][right] == -2:    # 거울일 때
            if direct == True:  # 오른쪽 방향으로 가다 거울
                up -= 1 # 위로 이동
                direct = False  # 방향 전환

            else:   # 위로 가다 거울 만남
                right += 1  # 오른쪽 이동
                direct = True

        if box[up][right] != 0 and box[up][right] != -2:    # 다른 구멍 도착
            mirror[i] = box[up][right]
            direct = True

# 아래쪽 번호 탐색
for i in range(1, M + 1):
    up, right, direct = N, i, True

    while mirror[i + N] == 0:
        if box[up][right] == 0:  # 거울이 아닐 때
            if direct == True:
                up -= 1 # 빛 위쪽 이동

            else:
                right += 1

        if box[up][right] == -2:    # 거울일 때
            if direct == True:  # 위로 가다 거울 만남
                right += 1  # 오른쪽 이동
                direct = False  # 방향 전환

            else:
                up -= 1 # 위쪽 이동
                direct = True   # 방향 전환

        if box[up][right] != 0 and box[up][right] != -2: # 다른 구멍 도착
            mirror[i + N] = box[up][right]
            direct = True

# 오른쪽 번호 탐색
for i in range(N, 0, -1):
    down, left, direct = i, M, True

    while mirror[right_num] == 0:
        if box[down][left] == 0:  # 거울이 아닐 때
            if direct == True:
                left -= 1  # 빛 왼쪽 이동

            else:
                down += 1

        if box[down][left] == -2:  # 거울일 때
            if direct == True:  # 왼쪽 방향으로 가다 거울
                down += 1  # 아래로 이동
                direct = False  # 방향 전환

            else:  # 아래로 가다 거울 만남
                left -= 1  # 왼쪽 이동
                direct = True

        if box[down][left] != 0 and box[down][left] != -2:  # 다른 구멍 도착
            mirror[right_num] = box[down][left]
            direct = True

    right_num += 1

# 위쪽 번호 탐색
for i in range(M, 0, -1):
    down, left, direct = 1, i, True # 기본 방향 아래

    while mirror[up_num] == 0:
        if box[down][left] == -2:   # 거울일 때
            if direct == True:
                left -= 1   # 왼쪽으로 경로 이동
                direct = False
            else:
                down += 1
                direct = True

        if box[down][left] == 0:    # 거울 아닐 때
            if direct == True:
                down += 1

            else:
                left -= 1

        if box[down][left] != 0 and box[down][left] != -2:  # 다른 구멍 도착
            mirror[up_num] = box[down][left]
            direct = True

    up_num += 1

result = []

for num in mirror.values():
    result.append(num)

print(*result)
```



### 2014. 소수의 곱

```python
# 2014. 소수의 곱
import heapq

# 우선순위 큐 = push, pop

K, N = map(int, input().split())

prime_nums = list(map(int, input().split()))

multi = []  # 곱

prime_num = 0   # 소수의 곱 중 N번째 수

for prime_num in prime_nums:    # 주어지는 소수 포함
    heapq.heappush(multi, prime_num)

for i in range(N):  # 큐에서 N번 빼면 그 값이 N번째 값
    prime_num = heapq.heappop(multi)

    for j in range(K):  # 꺼낸 소수에서 남아있는 소수들을 곱하여 힙큐에 넣는다.
        new = prime_num * prime_nums[j]
        heapq.heappush(multi, new)

        if prime_num % prime_nums[j] == 0:  # 중복 제거
            break

print(prime_num)

```



### 22115. 창영이와 커피

```python
# 22115. 창영이와 커피
N, K = map(int, input().split())

caffeine = [0] + list(map(int, input().split()))

# dp[i][j] : i개 까지의 커피를 모두 거쳤을 때 j만큼의 카페인을 위한 최솟값
dp = [[0] * (K + 1) for _ in range(N + 1)]

for i in range(1, K + 1):
    dp[0][i] = float("inf")

for i in range(1, N + 1):
    for j in range(1, K + 1):
        if j < caffeine[i]: # 현재 커피의 카페인 양이 현재 카페인보다 많을 때
            dp[i][j] = dp[i - 1][j]

        else:   # 이전 걸 마시거나 현재 카페인 양을 빼고 새롭게 마시기
            dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - caffeine[i]] + 1)

if dp[N][K] == float("inf"):
    print(-1)

else:
    print(dp[N][K])

```



### 7579. 앱

```python
# 7579. 앱
N, M = map(int, input().split())

active_memory = [0] + list(map(int, input().split()))

cost = [0] + list(map(int, input().split()))

_sum = sum(cost)

# dp[i][j] : i = 앱 / j 비용일 때의 메모리

dp = [[0] * (_sum + 1) for _ in range(N + 1)]

_min = sum(cost)

for i in range(1, N + 1):
    for j in range(1, _sum + 1):
        if j < cost[i]: # 현재 비용이 활성화 할 비용보다 작다면
            dp[i][j] = dp[i - 1][j]

        else:   # 지금까지 비용과 활성화한 비용에 메모리를 더한 것
            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - cost[i]] + active_memory[i])

        # 메모리 비교
        # 추가 확보해야하는 메모리보다 크거나 같고, 현재 비용이 작을 때
        if dp[i][j] >= M and _min > j:
            _min = j

print(_min)

```



## [19회차] 211223

### 2981. 검문

```python
# 2981. 검문
import sys
from math import gcd

N = int(input())

nums = [int(sys.stdin.readline().rstrip()) for _ in range(N)]

nums.sort(reverse=True)

get_gcd = []

# A, B, C => (A - B), (B - C) .. 의 gcd를 구하고 약수 구하기
for i in range(len(nums) - 1):
    get_gcd.append(nums[i] - nums[i + 1])

_gcd = get_gcd[0]

for i in range(1, len(get_gcd)):
    _gcd = gcd(_gcd, get_gcd[i])

result = set()

for i in range(2, int(_gcd ** (0.5)) + 1):
    if _gcd % i == 0:
        result.add(i)
        result.add(_gcd // i)

result.add(_gcd)

result = list(result)

result.sort()

print(*result)

```



### 1107. 리모컨

```python
# 1107. 리모컨
N, M = int(input()), int(input())

if M != 0:
    buttons = list(map(int, input().split()))   # 고장난 버튼

else:
    buttons = []

# case 1 : +, -로만 이동
cnt = abs(100 - N)

flag = False

# case 2 : 숫자 버튼으로 이동 후 +, - 로 조절
for num in range(1000001):
    channel = list(str(num))  # 채널

    for n in channel:
        if int(n) in buttons:   # 고장난 버튼
            flag = False
            break

        else:   # 고장나지 않은 버튼의 채널
            flag = True

    if flag is True:
        # 고장나지 않은 버튼의 채널 길이 + 현재 채널에서 목표 채널 +, - 버튼
        cnt = min(cnt, len(channel) + abs(num - N))

print(cnt)

```



## [20회차] 220106

### 2118. 두 개의 탑

```python
# 2118. 두 개의 탑
import sys

N = int(input())

distance = [int(sys.stdin.readline().rstrip()) for _ in range(N)]

_sum = sum(distance)

i, j, ans, result = 0, 0, 0, 0

while i < N - 1 and j <= N - 1:
    ans = ans + distance[j]  # 시계방향만 탐색

    if ans > (_sum - ans):  # 시계방향 > 반시계방향이면 넘어감 (두 거리 중 작은 거리가 계속 감소)
        i += 1
        j = i
        ans = 0
        continue

    j += 1

    result = max(ans, result)

print(result)

```



### 23629. 이 얼마나 끔찍하고 무시무시한 수식이니

```python
시간초과

# 23629. 이 얼마나 끔찍하고 무시무시한 수식이니
from collections import deque

word = input()

idx = 0

new, temp = '', ''

cal = ['x', '/', '+', '-']

flag = False

res = deque()

while word[idx] != '=' and flag is False:
    if word[idx] == 'Z':
        new += '0'
        temp += '0'
        idx += 4

    elif word[idx] == 'O':
        new += '1'
        temp += '1'
        idx += 3

    elif word[idx] == 'T':
        if word[idx + 1] == 'W':
            new += '2'
            temp += '2'
            idx += 3

        else:
            new += '3'
            temp += '3'
            idx += 5

    elif word[idx] == 'F':
        if word[idx + 1] == 'O':
            new += '4'
            temp += '4'
            idx += 4

        else:
            new += '5'
            temp += '5'
            idx += 4

    elif word[idx] == 'S':
        if word[idx + 1] == 'I':
            new += '6'
            temp += '6'
            idx += 3

        else:
            new += '7'
            temp += '7'
            idx += 5

    elif word[idx] == 'E':
        new += '8'
        temp += '8'
        idx += 5

    elif word[idx] == 'N':
        new += '9'
        temp += '9'
        idx += 4

    elif word[idx] == '+':
        res.append(int(temp))
        res.append('+')
        temp = ''

        new += '+'
        if word[idx + 1] in cal:
            print('Madness!')
            flag = True
            break
        else:
            idx += 1

    elif word[idx] == '-':
        res.append(int(temp))
        res.append('-')
        temp = ''

        new += '-'
        if word[idx + 1] in cal:
            print('Madness!')
            flag = True
            break
        else:
            idx += 1

    elif word[idx] == 'x':
        res.append(int(temp))
        res.append('x')
        temp = ''

        new += 'x'
        if word[idx + 1] in cal:
            print('Madness!')
            flag = True
            break
        else:
            idx += 1

    elif word[idx] == '/':
        res.append(int(temp))
        res.append('/')
        temp = ''

        new += '/'
        if word[idx + 1] in cal:
            print('Madness!')
            flag = True
            break
        else:
            idx += 1

if flag is False:
    change = {'0': 'ZERO', '1': 'ONE', '2': 'TWO', '3': 'THREE', '4': 'FOUR',
              '5': 'FIVE', '6': 'SIX', '7': 'SEVEN', '8': 'EIGHT', '9': 'NINE',
              '-': '-'}

    res.append(int(temp))

    result = (new + '=')

    ans = 0

    while res:
        c = res.popleft()

        if c not in cal:    # 연산자 아닐 때 ans에 숫자 저장
            ans = c

        else:   # c가 연산자 일 때
            c2 = res.popleft()  # 새로 뽑힌 숫자

            if c == 'x':
                ans *= c2

            elif c == '-':
                ans -= c2

            elif c == '+':
                ans += c2

            elif c == '/':
                ans //= c2

    ans = str(ans)

    answer = ''

    for i in ans:
        answer += change[i]

    print(result)
    print(answer)

```



### 3865. 학회원

```python
while True:
    def find_child(group_name, cnt):
        for member in group_dict.get(group_name, []):
            if member not in visited:
                visited.add(member)
                if group_dict.get(member, 0) == 0:
                    cnt += 1
                else:
                    cnt += find_child(member, 0)
        return cnt


    N = int(input())
    if N == 0:
        break

    group_dict = {}
    visited = set()
    first = ""

    for k in range(N):
        text = input()[:-1].split(":")
        text_key = text[0]
        text_arr = text[1].split(",")
        # 구해야 될 그룹 설정
        if k == 0:
            first = text_key
        if group_dict.get(text_key, 0) == 0:
            group_dict[text_key] = []
            group_dict[text_key].extend(text_arr)

    visited.add(first)
    print(find_child(first, 0))
```



## [21회차] 220113

### 16973. 직사각형 탈출

```python
"시간초과"

# 16973. 직사각형 탈출
import sys
from collections import deque


def wall(nx, ny):
    for i in range(H):
        for j in range(W):
            if board[nx + i][ny + j] == 1:
                return True
    return False


def BFS(x, y):
    visited[x][y] = 0   # 이동 시작

    q = deque()

    q.append((x, y))

    while q:
        x, y = q.popleft()

        if (x, y) == (Fr, Fc):  # 도착지점 종료 조건
            break

        for k in range(4):
            nx = x + dx[k]
            ny = y + dy[k]

            if visited[nx][ny] != -1:   # 방문 체크
                continue

            if 0 > nx or nx >= N - H + 1 or 0 > ny or ny >= M - W + 1:  # 범위 체크
                continue

            if wall(nx, ny):    # 직사각형과 벽이 겹치는지 확인
                continue


            # 직사각형이 겹치지 않을 때 좌측 상단 좌표(nx, ny)
            visited[nx][ny] = visited[x][y] + 1 # 이동횟수 추가
            q.append((nx, ny))


N, M = map(int, input().split())

# 1 : 벽
board = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]

H, W, Sr, Sc, Fr, Fc = map(int, input().split())

Sr -= 1
Sc -= 1
Fr -= 1
Fc -= 1

visited = [[-1] * M for _ in range(N)]  # 방문 check and 이동횟수 저장

dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

BFS(Sr, Sc)

print(visited[Fr][Fc])

```

```python
import sys
from collections import deque
def input():
    return sys.stdin.readline().rstrip()


def outOfBound(x,y):
    if 0<x<=N and 0<y<=M:
        return True
    return False
def OutOfBounds(x,y):
    if outOfBound(x,y) and outOfBound(x+A-1,y+B-1) and outOfBound(x+A-1,y) and outOfBound(x,y+B-1):
        return False
    return True

def Chks(x,y):
    if arr[x+A-1][y+B-1] - arr[x-1][y+B-1] - arr[x+A-1][y-1] + arr[x-1][y-1]:
        return True
    return False
def dfs():
    queue = deque()

    queue.append((*S,0))
    dx = [-1,0,1,0]
    dy = [0,1,0,-1]
    visited = [[False for _ in range(M+1)] for _ in range(N+1)]
    visited[S[0]][S[1]] = True
    while queue:
        cx,cy,dis = queue.popleft()


        for i in range(4):
            nx = cx + dx[i]
            ny = cy + dy[i]

            if OutOfBounds(nx,ny):
                continue
            if visited[nx][ny]:
                continue

            if Chks(nx,ny):
                continue
            visited[nx][ny] = True
            queue.append((nx,ny,dis+1))
            if (nx,ny) == E:
                return dis + 1
    return -1
N,M = map(int,input().split())


result = -1




arr = [[0 for _ in range(M+1)]]

for _ in range(N):
    temp = [0] + list(map(int,input().split()))
    arr.append(temp)

for x in range(1,N+1):
    for y in range(1,M+1):
        arr[x][y] = arr[x][y] + arr[x-1][y] + arr[x][y-1] - arr[x-1][y-1]

A,B,sx,sy,ex,ey = map(int,input().split())

S = (sx,sy)
E = (ex,ey)

print(dfs())
```



### 19952. 인성 문제 있어??

```python
# 19952. 인성 문제 있어??
from collections import deque

T = int(input())

dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

for tc in range(1, T + 1):
    H, W, obstacle, force, Xs, Ys, Xe, Ye, = map(int, input().split())
    board = [[0] * W for _ in range(H)]
    visited = [[False] * W for _ in range(H)]

    for _ in range(obstacle):
        X, Y, L = map(int, input().split())
        board[X - 1][Y - 1] = L

    # 이동
    def BFS(x, y, f):
        q = deque()
        q.append((x, y, f))
        visited[x][y] = True

        while q:
            x, y, f = q.popleft()

            if x == Xe - 1 and y == Ye - 1: # 목적지 도착
                return True

            if f <= 0:  # 힘 모두 소진
                return False

            for k in range(4):
                nx, ny = x + dx[k], y + dy[k]

                if 0 <= nx < H and 0 <= ny < W and visited[nx][ny] is False:
                    if f >= (board[nx][ny] - board[x][y]):
                        visited[nx][ny] = True
                        q.append((nx, ny, f - 1))

        return False


    if BFS(Xs - 1, Ys - 1, force):
        print("잘했어!!")

    else:
        print("인성 문제있어??")

```



### 2109. 순회강연

```python
# 2109. 순회강연
import sys, heapq

n = int(input())

info = []

money = 0

for _ in range(n):
    pay, day = map(int, sys.stdin.readline().split())

    info.append((pay, day))

info.sort(key=lambda x: x[1])   # day 오름차순 (강의한 날과 타 강의의 남은 날짜 비교)

q = []

for pay, day in info:
    heapq.heappush(q, pay)

    if day < len(q):
        heapq.heappop(q)    # 작은 값 꺼냄

print(sum(q))

```



### 23634. 미안하다 이거 보여주려고 어그로 끌었다

```python
# 2109. 미안하다 이거 보여주려고 어그로 끌었다
N, M = map(int, input().split())

dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

# 0 : 불, 1: 나무, 2: 돌
board = []

visited = [[0] * M for _ in range(N)]

for i in range(N):
    info = list(sys.stdin.readline().rstrip())
    board.append(info)


def BFS(x, y, size, time):
    print(x, y, size, time)


BFS(0, 0, 0, 0)

```



## [22회차] 220210

### 4949. 균형잡힌 세상

```java
import java.util.Scanner;
import java.util.Stack;
import java.io.FileInputStream;
import java.io.FileNotFoundException;

public class Main {

	public static void main(String[] args) throws FileNotFoundException {
		Scanner sc = new Scanner(System.in);
		
		String s;
		
		while(true) {
			s = sc.nextLine();
			
			// 입력 종료 조건
			if(s.equals(".")) {
				break;
			}
			// check 함수 실행
			System.out.println(check(s));
		}
		
	}
	
	public static String check(String s) {
		Stack<Character> stack = new Stack<>(); // Stack<Integer, Character ....>
		
		for(int i = 0; i < s.length(); i++) {
			char c = s.charAt(i); // 한글자씩
//			System.out.println(c);
			
			// '(', '[' 일 때
			if (c == '(' || c == '[' ) {
				// stack에 넣기
				stack.push(c);
			}
			
			// ')'일 때
			else if (c == ')') {
				// 스택이 비어있거나 최상단 원소가 '('가 아닐 때
				if (stack.empty() || stack.peek() != '(') {
					return "no";
				}
				// 꺼내기
				else {
					stack.pop();
				}
			}
			
			// ']'일 때
			else if (c == ']') {
				if (stack.empty() || stack.peek() != '[') {
					return "no";
				}
				else {
					stack.pop();
				}
			}
			
		}
		// 스택이 비어있거나 괄호가 하나도 없을 때
		if (stack.empty()) {
			return "yes";
		}
		else {
			return "no";
		}

	}

}

```



### 2179. 비슷한 단어

> 다시 풀기

```java
import static java.lang.Math.*;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

import javax.management.loading.PrivateClassLoader;

public class Main {

	public static void main(String[] args) throws FileNotFoundException {
		System.setIn(new FileInputStream("src/com/baekjoon/input.txt"));
		Scanner sc = new Scanner(System.in);
		
		String s, S = "", T = "";
		
		Integer t, cnt, c = 0, limit = 3;
		Integer _max = 0;
		
		List<String> wordList = new ArrayList<String>();
		List<String> finalList = new ArrayList<String>();
		

		t = sc.nextInt();
		
		for (int i = 0; i <= t; i++) {
			s = sc.nextLine();
			wordList.add(s);
		}
		
		wordList.remove(0); // 숫자 받은 후 왜 공백이 생기지....
		wordList.sort(null);
		
		for (int i = 0; i < wordList.size() - 1; i ++) {
			for (int j = i + 1; j < wordList.size(); j ++) {
				// 앞자리 다를 때
				if (wordList.get(i).charAt(0) != wordList.get(j).charAt(0)) {
					cnt = 1;
					continue;
				}
				
				else {
					cnt = 1;
					c += 1;
					// 공통 알파벳 개수 확인
					
					// 두 번째 글자가 더 길 때
					if (wordList.get(i).length() < wordList.get(j).length()) {
						
						for (int k = 1; k < wordList.get(i).length(); k ++) {
							if (wordList.get(i).charAt(k) == wordList.get(j).charAt(k)) {
								cnt += 1;
							}
							
							else {
								break;
							}
						}
						
						_max = cnt;
						S = wordList.get(i);
						T = wordList.get(j);

						finalList.add(S);
						finalList.add(T);
						String _maxString = Integer.toString(_max);
						finalList.add(_maxString);
						
						if (c == 1) {
							System.out.println(finalList.get(0));
							System.out.println(finalList.get(1));
						}
						
						else {
							for(int id = 0; id < finalList.size(); id += limit) {
								System.out.println(new ArrayList<>(finalList.subList(id, min(id + limit, finalList.size()))));
							}
						}
						
					}
					
//					// 첫 번째 글자가 더 길 때
//					else {
//						for (int k = 1; k < wordList.get(j).length(); k ++) {
//							if (wordList.get(i).charAt(k) == wordList.get(j).charAt(k)) {
//								cnt += 1;
//							}
//						}
//						if (_max < cnt) {
//							_max = cnt;
//							S = wordList.get(i);
//							T = wordList.get(j);
//						}
//					}
					
				}
			}
		}
	}
}

```



## [23회차] 220224

### 1057. 토너먼트

```java
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Baekjoon1057 {

	public static void main(String[] args) throws FileNotFoundException {
		// TODO Auto-generated method stub
		System.setIn(new FileInputStream("src/com/baekjoon/input.txt"));
		Scanner sc = new Scanner(System.in);
		
		int n = sc.nextInt(); // 참가자 수
		int jimin = sc.nextInt();	// 지민 번호
		int hansoo = sc.nextInt();	// 한수 번호
		int answer = 0;	// 경기수
		
		while(jimin != hansoo) {
			jimin = jimin / 2 + jimin % 2;
			hansoo = hansoo / 2 + hansoo % 2;
			answer ++;
		}
		
		System.out.println(answer);

	}

}

```



### 10026. 적록색약

```java
import java.io.IOException;
import java.io.InputStreamReader;
import java.text.DateFormatSymbols;
import java.util.Arrays;
import java.util.Scanner;


public class Baekjoon10026 {

	static int N;
	static String s;
    static char array[][];	// 색 정보 받기
    static boolean visited[][]; // 방문
    static int dx[] = {-1, 0, 1, 0};
    static int dy[] = {0, 1, 0, -1};

    public static void main(String[] args) throws IOException {
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    	Scanner scanner = new Scanner(System.in);
    	N = scanner.nextInt();

//        int N = Integer.parseInt(br.readLine());
        
        array = new char[N+1][N+1];
        visited = new boolean[N+1][N+1];
        
        int cnt = 0; // 영역

        for (int i = 0; i < N; i++) {
//        	s = br.readLine();
        	s = scanner.next();
        	for (int j = 0; j < N; j++) {
        		array[i][j] = s.charAt(j);
        	}
        }
        // 2차원 배열 출력 방법
//        System.out.println(Arrays.deepToString(array));
        
        // case1) 정상인
        for (int i = 0; i < N; i++) {
        	for (int j = 0; j < N; j++) {
        		if (!visited[i][j]) {
        			dfs(i, j);
        			cnt++;
        		}
        	}
        }
        
        // 초기화
        int cnt1 = cnt;
        cnt = 0;
        visited = new boolean[N+1][N+1];
        
        // case2) 색맹
        for(int i = 0; i < N; i++){
            for(int j = 0; j < N; j++){
                if(array[i][j] == 'R'){
                    array[i][j] = 'G';
                }
            }
        }
        
        for (int i = 0; i < N; i++) {
        	for (int j = 0; j < N; j++) {
        		if (!visited[i][j]) {
        			dfs(i, j);
        			cnt++;
        		}
        	}
        }
        
        System.out.println(cnt1 + " " + cnt);

    }
    // dfs
    public static void dfs(int x, int y){
        visited[x][y] = true;
        char alpha = array[x][y];
        for(int k = 0; k < 4; k++){
            int nx = x+dx[k];
            int ny = y+dy[k];
 
            if (nx < 0 || ny < 0 || nx > N || ny > N){
                continue;
            }
 
            if (!visited[nx][ny] && array[nx][ny] == alpha){
                dfs(nx, ny);
            }
        }
    }
}

```



### 3541. 상근타워

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;


public class Main {
    static int array[][];

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());
        
        int u, d;
        
        int _min = 9999999;

        for (int i = 0; i < M; i++) {
            st = new StringTokenizer(br.readLine());
            u = Integer.parseInt(st.nextToken());
            d = Integer.parseInt(st.nextToken());
            
            for (int j = 0; j <= N + 1; j ++) {
            	if (u * (N - j) - (d * j) > 0 && u * (N - j) - (d * j) < _min) {
            		_min = (u * (N - j) - (d * j));
            	}
            }
            
        }
        System.out.println(_min);
    }
}

```



## [24회차] 220302

### 7576. 토마토

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

import javax.swing.plaf.basic.BasicInternalFrameTitlePane.MaximizeAction;

class Tomato {
	int x;
	int y;
	
	Tomato(int x, int y) {
		this.x = x;
		this.y = y;
	}
}

public class Main {
	
	static int M, N, _max;
    static int array[][]; // 1: 익음 / 0 : 익지 않음 / -1 : 토마토 없음
    static int visited[][];
    static int dx[] = {-1, 0, 1, 0};
    static int dy[] = {0, 1, 0, -1};	

	public static void main(String[] args) throws IOException {
		// TODO Auto-generated method stub
		BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer stringTokenizer = new StringTokenizer(bufferedReader.readLine());
		
		M = Integer.parseInt(stringTokenizer.nextToken());
		N = Integer.parseInt(stringTokenizer.nextToken());
        
		array = new int[N][M];
        visited = new int[N][M];
		
		// 큐
		Queue<Tomato> q = new LinkedList<>();
		
		for (int i = 0; i < N; i ++) {
			stringTokenizer = new StringTokenizer(bufferedReader.readLine(), " ");
			for (int j = 0; j < M; j ++) {
				int tomato = Integer.parseInt(stringTokenizer.nextToken());
				
				array[i][j] = tomato;
				
				// 익은 토마토 => q에 넣기
				if (tomato == 1) {
					q.offer(new Tomato(i, j));
				}
				// 익지 않음 => 방문하지 않음
				else if (tomato == 0) {
					visited[i][j] = -1;
				}	
			}
		}
		
		while (!q.isEmpty()) {
			// 익은 토마토 하나씩 꺼내기
			Tomato to = q.poll();
			
			for (int k = 0; k < 4; k ++) {
				int nx = to.x + dx[k];
				int ny = to.y + dy[k];
				
				// 범위 확인
				if (nx < 0 || nx >= N || ny < 0 || ny >= M) {
					continue;
				}
				
				// 익지 않은 토마토 무시
				if (array[nx][ny] != 0) {
					continue;
				}
				
				// 방문 체크 (익지 않은 토마토만 확인)
				if (visited[nx][ny] >= 0) {
					continue;
				}
				// 하루 늘리기
				visited[nx][ny] = visited[to.x][to.y] + 1;
				
				q.offer(new Tomato(nx, ny));
			}
		}
		// 모두 익을 때까지의 날짜
		for (int i = 0; i < N; i ++) {
			for (int j = 0; j < M; j ++) {
				if (visited[i][j] == -1) {
					System.out.println(-1);
					return;
				}
				_max = Math.max(_max, visited[i][j]);
			}
		}
		System.out.println(_max);
	}
}

```



### 17089. 세 친구

```java
import java.io.*;
import java.util.*;

public class Main {
	
	static int N, M, A, B, cnt; // 사람 수, 친구 관계 수, 친구 관계, 친구 최소
	static int _min = 999999;
	static int array[][];

	public static void main(String[] args) throws IOException {
		// TODO Auto-generated method stub
		BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer sTokenizer = new StringTokenizer(bufferedReader.readLine());
		
		N = Integer.parseInt(sTokenizer.nextToken());
		M = Integer.parseInt(sTokenizer.nextToken());
		
		array = new int[N + 1][N + 1];
		
		for (int i = 0; i < M; i++) {
			sTokenizer = new StringTokenizer(bufferedReader.readLine(), " ");
			A = Integer.parseInt(sTokenizer.nextToken());
			B = Integer.parseInt(sTokenizer.nextToken());
			
			array[A][B] = 1;
			array[B][A] = 1;
		}
		
//		System.out.println(Arrays.deepToString(array));
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {
				// i와 j가 친구라면
				if (array[i][j] == 1) {
					// 나머지 한 친구
					for (int k = 0; k < N; k++) {
						// 세 친구일 때
						if (array[k][i] == 1 && array[j][k] == 1) {
							// 친구의 수 구하기
							int cnt = check(array, i, j, k, 0);
							
							if (_min > cnt) {
								_min = cnt;
							}
						}
					}
				}
			}
		}
		
		if (_min == 999999) {
			System.out.println(-1);
		} else {
			System.out.println(_min);
		}

	}
	public static int check(int[][] array, int a, int b, int c, int cnt) {
		for (int i = 1; i < array.length; i++) {
			if (array[a][i] == 1) {
				cnt += 1;
			}
			if (array[b][i] == 1) {
				cnt += 1;
			}
			if (array[c][i] == 1) {
				cnt += 1;
			}
		}
		// 세 친구 빼기
		return cnt - 6;
	}
}

```



